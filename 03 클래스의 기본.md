03 클래스의 기본
=======================
# 1. C++에서의 구조체
클래스의 탄생은 간단하다. 
기존 함수는 전역이다.  
전역은 누구나 호출할 수 있는 것으로 모든 데이터에 사용하지 않음에도 사용 가능한 문제점이 발생할 수 있다.     
그렇기에 구조체에 함수를 넣어서 잘못된 접근을 최소화 시키거나 미연에 방지시킬 수 있다. 
      
**구조체의 등장 배경**   
      
* 연관 있는 데이터를 하나로 묶으면 프로그램의 구현 및 관리가 용이하다.     
* 구조체는 연관 있는 데이터를 하나로 묶는 문법적 장치이다.        
         
연관있는 데이터들은 생성 및 소멸의 시점이 일치하고,     
이동 및 전달의 시점 및 방법이 일치하기 때문에 하나의 자료형으로 묶어서 관리하는 것이 용이하다.    

## 1.1. C++ 에서의 구조체 변수 선언    
**C 스타일 구조체 변수 초기화**
```
struct Car basicCar;
struct Car simpleCar;
```
**C++ 스타일 구조체 변수 초기화**
```
Car basicCar;
Car simpleCar;
```
기존 C에서 struct 키워드의 생략을 위한 typedef선언이 불필요하다.      
클래스는 데이터 뿐만 아니라, 해당 데이터와 연관된 함수들도 함께 그룹을 형성하기 때문에         
함수도 하나로 묶는 것에 대해 나름의 가치를 부여할 수 있다.          
       
**클래스 만들기**
```
struct Car
{
      char ganerID[ID_LEN]
      int fuelGauge;
      int curSpeed;

      void ShowCarState()
      {
            cout<<"소유자ID: "<<ganerID<<endl;
            cout<<"연료량: "<<fuelGauge<<"%"<<endl;
            cout<<"현재속도: "<<curSpeed<<"km/s"<<endl;
      }
      void Break()
      {
       if(curSpeed < BRK_STEP)
       {
            curSpeed=0;
            return;
       }
       curSpeed -= BRK_STEP;
      }
      void Accel()
      {
       if(fuelGauge <= 0){
            return;
       } else{
            fuelGauge=FUEL_STEP;
       }
       
       if(curSpeed+ACC_STEP >=MAX_SPD){
            curSpeed=MAX_SPD;
            return;
       }
       curSpeed += ACC_STEP;
      }
}
```
C++에서는 구조체 안에 함수를 삽입하는 것이 가능하다.   
따라서 C++에서는 구조체가 아닌, 클래스라 한다.     
동일한 클래스내에서 존재하는 변수와 함수는 직접 접근할 수 있다.     
    
**클래스 변수 선언하기(객체 생성하기)**    
```
Car run99 = {"run99", 100, 0}
Car sped77 = {"sped77", 100, 0}
```
이와 같이 변수에 대한 값만 할당했더라도 해당 클래스에는 함수도 존재한다고 생각하자.      
  
## 1.2. 구조체 안에 enum 상수의 선언   
상수들 중에도 특정 클래스에게만 의미있는 상수들이 있을 수 있다.   
즉, 다른 영역에서 사용하도록 정외된 상수가 아니니, 이들 상수도 구조체 내에 포함시키는 것이 좋을 수 있다.  
따라서 이러한 경우에는 열거형 ```enum```을 이용해서 구조체 내에서만 유효한 상수를 정의하면 된다.   
  
**enum 상수**
```
struct Car
{
      enum
      {
            ID_LEN = 20,
            MAX_SPD = 200,
            FUEL_STEP = 2,
            ACC_STEP = 10,
            BRK_STEP = 10,
      }
      
      char gameID[ID_LEN];
      int fuelGauge;
      int curSpeed;
      
      void ShowCarState() {.....}
      void Accel() {.....}
      void Break() {.....}
}
```
열거형은 하나의 메모리룰 공유하는 값들을 지정해주는 것이다.   
즉, 4bye 메모리를 여러 변수, 상수들이 공통으로 사용하는 것이다.   
  
참고로 enum의 선언을 구조체 내부에 삽입하는 것이 부담스럽다면,  
이름공간을 이용해서 상수가 사용되는 영역을 명시하는 것도 또 다른 방법이 될 수 있다.  
(이름 공간을 이용하면 한개가 아닌 몇몇의 구조체 사이에서만 사용하는 상수 선언시 도움이 된다.)   

```
namespace CAR_CONST
{
      enum
      {
            ID_LEN      = 20;
            MAX_SPD      = 200;
            FUEL_STEP      = 2;
            ACC_STEP      = 10;
            BRK_STEP      = 10;
      }
}
```



### 1.2.1. 내용1
```
내용1
```

***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
