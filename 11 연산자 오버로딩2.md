11 연산자 오버로딩2
=======================
# 1. 반드시 해야 하는 대입 연산자의 오버로딩
## 1.1. 객체간 대입 연산의 비밀: 디폴트 대입 연산자      
기존에 생성된 객체를 가지고 기존의 객체를 초기화 하는 경우에 사용된다.        
```opertator=()``` 으로 따로 메소드를 정의하지 않으면 디폴트 대입 연산자가 호출된다. 
    
![cpp68](https://user-images.githubusercontent.com/50267433/75637660-3f364a00-5c6b-11ea-9fa2-efa322484945.PNG)   
    
디폴트 대입 연산자는 멤버 변수에 따라 알맞게 정의 되어진다.     
    
## 1.2. 디폴트 대입 연산자의 문제점
만약 멤버 변수에서 포인터 변수로 참조를 하는 경우 디폴트 대입 연산자를 사용할 경우 문제점이 생긴다.     
멤버가 복사가 되는 것이므로 참조하는 주소값을 복사가 되어지고       
이로 인해 2개의 객체의 멤버가 같은 메모리를 가리키는 얕은 복사의 문제가 발생한다.      
    
![cpp71](https://user-images.githubusercontent.com/50267433/75637793-d7343380-5c6b-11ea-8d0e-091afcfede5e.PNG)   
     
이를 해결하고자 깊은 복사를 위한 복사 생성자와 유사하게 코드를 작성해주면 된다.  
단, 차이점은 메모리 누수를 위한 멤버 변수 delete 구문이 추가 되었다.  
   
## 1.3. 상속 구조에서의 대입 연산자 호출   
디폴트 대입 연산자는 기초 클래스의 대입 연산자를 호출해준다.(이 부분은 매우 똑똑하다)         
![cpp69](https://user-images.githubusercontent.com/50267433/75639744-a527cf00-5c75-11ea-93cb-8d8e8a3593d2.PNG)      
그러니 명시적으로 대입 연산자를 정의하게 되면, 기초 클래스의 대입 연산자 호출도 별도로 명시해주어야 한다.       

## 1.4. 이니셜라이저의 성능 향상 도움
이니셜라이저를 이용해서 멤버를 초기화하면, 함수 호출의 수를 1회 줄일 수 있다.     
    
![cpp70](https://user-images.githubusercontent.com/50267433/75639790-d56f6d80-5c75-11ea-936f-68b89dfb1514.PNG)   
       
생성자 내에서 ```=```를 사용하는 것도 연산자 오버로딩 함수를 실행 한것으로 총 2번의 함수 호출이 일어난 것이다.       
반대로 이니셜라이저를 사용하면 생성과 동시에 초기화를 진행하므로 1회만 호출된 것으로 볼 수 있다.        
      
*** 
# 2. 배열의 인덱스 연산자 오버로딩 
## 2.1. 배열보다 나은 배열 클래스     
배열보다 배열 클래스의 나은점은 개발자가 기능을 추가적으로 구현할 수 있다는 점이다.      
![cpp72](https://user-images.githubusercontent.com/50267433/75640711-4fedbc80-5c79-11ea-81e4-f1439efb26d5.PNG)       
예를 들면 배열의 범위를 넘어선 인덱스 값을 사용하더라도        
포인터 연산으로 진행되기에 에러 없이 실행 된다는 문제점이 있다.       
  
하지만 이러한 문제점을 배열 클래스를 이용하여 해결해 줄 수 있다.     
배열 클래스를 정의할 때 경계 검사 코드를 추가로 삽입하여 이러한 문제점을 해결할 수 있다는 것이다.         
  
그리고 이러한 배열 클래스는 ```[]```연산자 오버로딩을 작성하여 배열과 유사하게 이용할 수 있다.      
      
```
arrObject[2];
```
연산자 오버로딩을 통해서 다음과 같이 배열처럼 접근이 가능한 객체의 모습이다.      

```
arrObject.operator[](2);
```
이는 위와 같이 해석이 된다.  

```
int operator[] (int index){......}
```   
때문에 ```[]```연산자는 아래와 같이 오버로딩 해야한다.    
   
## 2.2. 배열 클래스의 예
![cpp73](https://user-images.githubusercontent.com/50267433/75641125-8e37ab80-5c7a-11ea-87ef-7cb2790e3159.PNG)
앞서 설명한 경계 검사를 추가해주었다.    
   
**경계 검사**
```
if(idx < 0 || idx >= arrlen){
    cout<<"Array index out of bound Exception"<<endl;
    exit(1);
}
```
## 2.3. 배열 클래스의 안전성 확보 
배열은 저장소의 일종이고, (데이터를 저장했는데 이를 복사하는 것은 철학에 안맞음)       
저장소에 저장된 데이터는 유일성이 보장되어야 하기 때문에 ```배열 = 배열``` 복사는 불가능 하다.        
               
배열 객체를 대상으로 하는 복사와 관련된 연산은 모두 불가능하게 해야 할 필요도 있다.  
(물론 상황에 따라서 복사를 해야 된다면 따로 방법을 마련해두자)                
```
SampleClassArray arr = cpy    ->    X   : 복사 생성자  
arr = cpy1                    ->    X   : 대입 연산자
```   
     
![cpp74](https://user-images.githubusercontent.com/50267433/75641737-a27ca800-5c7c-11ea-80bc-9c1f7bdacf69.PNG)   
      
     
이렇듯 배열을 복사하거나 생성시 할당 초기화가 되지 않도록 처리를 해주고자     
복사와 관련된 연산의 제한을 위해서 복사 생성자와 대입 연산자를 ```private``` 로 선언한다.  

## 2.4. const 함수를 이용한 오버로딩의 활용   
함수의 const 유무는 함수 오버로딩의 조건이 된다.      
       
![cpp75](https://user-images.githubusercontent.com/50267433/75642235-1cf9f780-5c7e-11ea-9e6e-1b88189e1c7c.PNG)  
      

const 함수를 정의하는 경우는 단순히 함수 호출을 위해서이다.  
const 배열 클래스에서 인덱스를 이용하여 값을 얻더라도 변경이 불가능 해야하므로 const 메소드가 정의되어야 한다.    
  
반대로 일반 배열 클래스에서는 이러한 인덱스를 이용해서 값을 변경하는 일이 주된 목적일 것이다.    
그렇기에 const 함수가 아닌 다른 일반 함수를 정의 해주어야 하며       
반환형을 참조자 형태로 주어 실제 메모리 접근인 call-by-reference가 진행되도록 해주어야 한다.           
(일반 자료형으로 하면 복사가 이루어지기 때문에 값을 변경해도 변경이 일어나지 않는다.)            
       
결론을 말하자면 일반적으로 operator[] 함수는 const 함수와 일반함수가 동시에 정의하자.        
     
## 2.5. 객체의 저장을 위한 배열 클래스1          
객체의 저장 방법은 2가지이다.           
첫번째 방법은 객체를 통째로 저장하는 방법이고            
두번째 방법은 객체의 주소 값을 저장하는 방법이 있다.      
         
![cpp76](https://user-images.githubusercontent.com/50267433/75642905-824ee800-5c80-11ea-8d05-cdeb59ea2a69.PNG)     
        
위 그림은 객체를 통째로 저장하는 방법이다.          
일반 자료형이 아닌 클래스를 대상으로 정의된 배열 클래스이다.           
생성할 때 ```new 내부 클래스[길이]```를 이용해서 생성한다.       
        
이렇게 객체를 통째로 저장을 한다는 것은       
```객체 = 객체```형태이지만 사실상 ```클래스 포인터 변수 = 클래스 객체```이므로          
```멤버 대 멤버```복사 연산자가 진행되어 저장되는 것이다. (같은 자료형을 띄우고 있기에)      
    
무슨 뜻이냐면 같은 ```자료형의 포인터 변수 = 객체```이기에 복사 연산이 진행되는 것이다.   
## 2.6. 객체의 저장을 위한 배열 클래스2
![cpp77](https://user-images.githubusercontent.com/50267433/75650481-4f651e00-5c99-11ea-9295-1219ba2d1cb1.PNG)
      
위 그림은 객체의 주소 값을 저장하는 방법이다.                   
여기서는 더블 포인터를 이용해서 객체를 단순히 참조하는 형태로 만들었기에 복사 연산자를 진행하지 않는다.               
그렇기에 연산이 1회 줄어들고 복사 연산자에 관해 신경쓰지 않아도 되니 더 많이 사용하는 방법이다.   
      
***  
# 3. 그 이외의 연산자 오버로딩 
## 3.1. new 연산자 오버로딩에 대한 상세한 이해        
![cpp78](https://user-images.githubusercontent.com/50267433/75654385-f4d0bf80-5ca2-11ea-9160-6aa690d8a1ed.PNG)           
           
**new 연산자가 하는일**            
1. 메모리 공간의 할당          
2. 생성자의 호출           
3. 할당하고자 하는 자료형에 맞게 반환된 주소 값의 형변환           
                
이 중에서 2번과 3번은 고정이여서 오버로딩이 불가능하다. (에러 발생)                       
우리는 **메모리 공간의 할당만을 오버라이딩 할 수 있다.**                        
```
void * operator new (size_t size)
{
    void * adr = new char[size];
    return adr;
}  
```
반환형, 매개변수, return 모두 우리는 정의가 불가능 하고              
여기서 ```void * adr = new char[size];```만 우리가 오버라이딩 정의 가능하다.            
그리고 오버라이딩이라 해서 내용을 완전히 바꾸는 것이 아닌        
메모리에 관해서만 정의한다고 보면 된다.        
       
사실 생각해보면 new 연산자는 '자동'으로 객체에 맞게 메모리를 할당하고 형변환하여 반환한다.              
그렇기에 이러한 부분은 사용자가 정의를 하지 않는 편이 좋은 것이다.                
           
또한 객체가 생성된 상태가 아니더라도 new 함수를 호출이 가능한 것은     
new 연산자와 delete 연ㅅ나자를 오버로딩 하고 있는 함수가 자동으로 static 선언이 되기 때문이다.   
## 3.2. delete 연산자 오버로딩에 대한 이해와 예제        
![cpp79](https://user-images.githubusercontent.com/50267433/75655955-49296e80-5ca6-11ea-9e57-87d60a0855c5.PNG)       
        
```delete``` 연산자의 오버로딩은 '해제'를 위한 정의를 해주면 된다.       
소멸자에 대한 호출은 delete에서 알아서 할 것이다.     
   
## 3.3. operator new & operator new []  
**2 가지 형태의  new 연산자 오버로딩**    
```
void * operator new (size_t size) {. . . . . .}
void * operator new[] (size_t size) {. . . . . .}
```
우리는 ```new``` 연산자를 기준으로   
**하나의 데이터를 대상**으로 또는     
**배열의 형태로 클래스를 대상**으로 작성할 수 있다.  

![cpp80](https://user-images.githubusercontent.com/50267433/75660162-a4f7f580-5cae-11ea-99b5-c0898168a2cf.PNG)


하지만 ```delete``` 연산자일 경우 조금 다르다.     
단순 ```delete``` 문 에서는 ```delete 객체;```를 사용할 것 같지만      
실상은 ```delete []객체```형태이다 왜 그럴까?     
   
사실 우리는 ```new```연산자에서 **바이트 단위의 배열**로 메모리를 할당해주었다.    
그렇기에 1개의 객체라고 하더라도 이는 바이트 단위의 메모리로 생성이 되었기에      
해제할 때도 마찬가지로 배열 형태로 해제를 진행해주어야 한다.      
      
## 3.4. 포인터 연산자 오버로딩         
포인터 연산자라는 것은 ```->```와 ```*``` 연산자를 의미하는 것이다.          
           
![cpp81](https://user-images.githubusercontent.com/50267433/75660909-b8579080-5caf-11ea-9330-dd1d1792bf16.PNG)      
             
```*```연산자는 이미 곱셈 연산에서 진행될 수 있다.       
하지만 여기서 보면 매개변수가 void 형태로 두개의 피연산자를 가지는 ```*```과는 겹치지 않을 것이다.     
     
```->```와 ```*```의 차이점은            
```->```는 포인터 대상을 포인터로 반환하고      
```*```는 포인터 대상의 값 메모리를 참조자 형태로 반환한다.          
       
그렇다면 여기서 ```->```연산자를 사용했을시 멤버 변수와 함수에 접근하는 방법은 무엇일까?            
바로 이렇게 반환된 포인터 대상을 통해서 **약속**으로 알맞는 변수나 함수를 리턴한다.                  
               
즉, ```num->showData();```일 경우 ```(num.operator->()).showData();``` 형태가 되는 것이다.                 
              
```*```도 마찬가지이다 ```(*num)=30```같은 경우 ```(num.operator*())=30```으로 해석이 된다.             
  
## 3.5. 스마트 포인터 
포인터 처럼 동작하는,                  
포인터보다 다소 똑똑하게 동작하는 객체를 가리켜 스마트 포인터라 한다.                      
                   
 ![cpp82](https://user-images.githubusercontent.com/50267433/75664173-5f8af680-5cb5-11ea-97a6-b8b26f51eb11.PNG)          
                 
위의 스마트 포인터는 자신이 참조하는 객체의 소멸을 대신해주는 똑똑한 포인터이다.                              
쉽게 말하면 포인터처럼 동작하게끔 만든 클래스이자 객체이다.                  
대신 개발자가 세부적으로 정의를 할 수 있으므로 똑똑한 포인터라고 명칭한 것이다.                  
                
코드를 분석해보자면 클래스 내에는 포인터형 변수가 존재하고            
포인터 연산자 오버로딩을 이용해서 포인터 연산자의 특성인 '대상'을 return 받아서 '대상'을 기준으로 처리를 진행한다.             
             
우선 객체 생성시 생성자에 가리킬 대상을 인자로 주입시켜준다.      
이를 통해 내부 포인터 변수가 해당 객체를 가리키는 형태가 되었다.        
그리고 이러한 포인터 변수를 통해서 다양한 포인터 연산을 활용할 수 있는데      
예를 들면 ```sptr->showPos()```같은 경우도               
```sptr->```에서 ```sptr.operator->()```이 호출되고 반환된 대상을 통해 ```showPos()```를 호출한다.           
         
그렇다면 무엇이 똑똑하냐?   
소멸자를 분석해보면 내가 참조하는 대상에 delete 연산을 진행하고 있다.  
 
이는 다시 생각해보면 외부에서 생성된 객체를 스마트 포인터가 참조할 뿐인데      
이를 스마트 포인터가 소멸되면서 동시에 같이 삭제해주는 메모리 누수를 방지해준다.    

## 3.6. 연산자의 오버로딩과 펑터(Functor)   
     
![cpp83](https://user-images.githubusercontent.com/50267433/75679627-590b7780-5cd3-11ea-8659-5b12c6003c32.PNG)        
        
**```()```연산자의 오버로딩**      
* 객체를 함수처럼 사용할 수 있게 하는 오버로딩            
* 객체의 멤버함수를 함수처럼 호출할 수 있게 하는 오버로딩       

**adder가 객체의 이름이라면**   
```adder(2,4);```와 같이 함수처럼 사용을 한다.  
그리고 이는 ```adder.operator()(2,4);```로 해석이 된다.
   
이렇듯 함수처럼 호출이 가능한 객체를 가리켜 ```Functor```라 부른다.     
      
```
class Adder
{
public:             
    int operator()(int a, int b)
    {
        return n1+n2;
    }
    double operator()(const double& e1, const double& e2)
    {
        return e1+e2;
    }
    Point operator()(const Point& pos1, const Point& pos2)
    {
        return pos1+pos2
    }
}
```
```
int main(void)
{
    Adder adder;
    cout<<adder(1, 3)<<endl;
    cout<<adder(1.5, 3.7)<<ednl;
    cout<<adder(Point(3,4), Point(7,9))
}
```
객체에 ```()```를 사용하는 것이므로 생성자로 헷갈릴만 하지만 ```functor```는 객체를 목적이 아니므로     
객체생성을 해서 초기화 또는 대입하는 것이면 생성자로 추측하고  
return 값이 boolean 이거나 리터럴 값인 경우 functor로 추측이 가능하다.   
   
이러한 functor는 주로 조건의 기준으로 사용된다. 

## 3.7. Functor의 위력 (조건의 기준)   
   
![cpp84](https://user-images.githubusercontent.com/50267433/75682143-48a9cb80-5cd8-11ea-919b-f05b8caccc0e.PNG)      
    
위 코드를 간단히 해석하면         
메소드에서는 SortRule형 객체를 인자로 받을 수 있고            
이 SortRule형 참조 변수인 functor 를 이용하여 ```if``` 조건식의 판단을 내린다.        

여기서 SortRule을 상속받는 클래스는 2개인데 하나는 오름차순 하나는 내림차순으로 나타내는 값을 리턴한다.  

즉, fuctor의 반환값에 따라 분기가 나뉘어진다고 생각하면 된다.(오름차순 할거냐 내림차순 할거냐 등)   

## 3.8. 임시객체로의 자동 형 변환   
     
![cpp85](https://user-images.githubusercontent.com/50267433/75682825-67f52880-5cd9-11ea-9ebb-45cbb24bdc4a.PNG)   
      
1. num 객체 생성   
```
Number num;
```
    1. ```cout<<"Number(int n=0)"<<ednl``` 진행    
       
2. num 객체에 정수 할당      
```num=30```               
하지만 사실 ```=```은 양측의 타입이 일치해야 한다.               
그렇기에 이를 자동 형 변환을 시켜 ```num = Number(30);```형태를 띄게 하였다.            
          
3. ```=```연산 진행          
```=```연산을 진행하니 ```operator=``` 형태로 호출                   
즉, ```num.operator=(Number(30))``` 으로 동작                 
    1. ```Number(30)``` 진행 -> ```cout<<"Number(int n=0)"<<ednl``` 진행        
    2. ```num.operator()``` 진행 -> ```cout<<"operator()"<<endl``` 진행                 
    3. ```num = ref.num``` 진행 -> ```cout<<"Number(int n=0)"<<ednl``` 진행     
       
4. ```num.ShowNumber();```진행         
단순히 메소드 호출            
    1. ```cout<<num<<endl``` 호출            
  
**결과**  
```
Number(int n=0)
Number(int n=0)
operator=()
Number(int n=0)
50
```

