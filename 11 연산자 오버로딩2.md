11 연산자 오버로딩2
=======================
# 1. 반드시 해야 하는 대입 연산자의 오버로딩
## 1.1. 객체간 대입 연산의 비밀: 디폴트 대입 연산자      
기존에 생성된 객체를 가지고 기존의 객체를 초기화 하는 경우에 사용된다.        
```opertator=()``` 으로 따로 메소드를 정의하지 않으면 디폴트 대입 연산자가 호출된다. 
    
![cpp68](https://user-images.githubusercontent.com/50267433/75637660-3f364a00-5c6b-11ea-9fa2-efa322484945.PNG)   
    
디폴트 대입 연산자는 멤버 변수에 따라 알맞게 정의 되어진다.     
    
## 1.2. 디폴트 대입 연산자의 문제점
만약 멤버 변수에서 포인터 변수로 참조를 하는 경우 디폴트 대입 연산자를 사용할 경우 문제점이 생긴다.     
멤버가 복사가 되는 것이므로 참조하는 주소값을 복사가 되어지고       
이로 인해 2개의 객체의 멤버가 같은 메모리를 가리키는 얕은 복사의 문제가 발생한다.      
    
![cpp71](https://user-images.githubusercontent.com/50267433/75637793-d7343380-5c6b-11ea-8d0e-091afcfede5e.PNG)   
     
이를 해결하고자 깊은 복사를 위한 복사 생성자와 유사하게 코드를 작성해주면 된다.  
단, 차이점은 메모리 누수를 위한 멤버 변수 delete 구문이 추가 되었다.  
   
## 1.3. 상속 구조에서의 대입 연산자 호출   
디폴트 대입 연산자는 기초 클래스의 대입 연산자를 호출해준다.(이 부분은 매우 똑똑하다)         
![cpp69](https://user-images.githubusercontent.com/50267433/75639744-a527cf00-5c75-11ea-93cb-8d8e8a3593d2.PNG)      
그러니 명시적으로 대입 연산자를 정의하게 되면, 기초 클래스의 대입 연산자 호출도 별도로 명시해주어야 한다.       

## 1.4. 이니셜라이저의 성능 향상 도움
이니셜라이저를 이용해서 멤버를 초기화하면, 함수 호출의 수를 1회 줄일 수 있다.     
    
![cpp70](https://user-images.githubusercontent.com/50267433/75639790-d56f6d80-5c75-11ea-936f-68b89dfb1514.PNG)   
       
생성자 내에서 ```=```를 사용하는 것도 연산자 오버로딩 함수를 실행 한것으로 총 2번의 함수 호출이 일어난 것이다.       
반대로 이니셜라이저를 사용하면 생성과 동시에 초기화를 진행하므로 1회만 호출된 것으로 볼 수 있다.        
      
*** 
# 2. 배열의 인덱스 연산자 오버로딩 
## 2.1. 배열보다 나은 배열 클래스
배열 클래스를 기반으로 생성되는 배열 객체는 배열과 동일한 기능을 하되, 경계검사의 기능을 추가한 객체이다.     
    
연산자 오버로딩을 통해서 다음과 같이 배열처럼 접근이 가능한 객체이다.   
```
arrObject[2];
```
이는 다음과 같이 해석이 된다.  
```
arrObject.operator[](2);
```
때문에 다음의 형태로 오버로딩 해야한다.  
```
int operator[] (int index){......}
```
아마도 위의 코드에서는 index숫자에 해당하는 배열 요소중 하나를 반환할 것이다.  

## 2.2. 배열 클래스의 안전성 확보   
배열은 저장소의 일종이고, 저장소에 저장된 데이터는 유일성이 보장되어야 하기 때문에     
배열 객체를 대상으로 하는 복사와 관련된 연산은 모두 불가능하게 해야 할 필요도 있다.(물론 상황에 따라서)   
```
arr = cpy1                    ->    X
또는
SampleClassArray arr = cpy    ->    X
```   
이렇듯 배열을 복사하거나 생성시 할당 초기화가 되지 않도록 처리를 해주고자  
복사와 관련된 연산의 제한을 위해서 복사 생성자와 대입 연산자를 ```private``` 로 선언한다.

## 2.3. const 함수를 이용한 오버로딩의 활용   
함수의 const 유무는 함수 오버로딩의 조건이 된다.      
    
const 참조자로 참조하는 경우의 함수 호출을 위해서 정의된 함수!     
그런데 이 함수를 대상으로는 맴버변수의 값을 변경할 수 없으니,      
const로 선언되지 않은다음 함수가 추가로 정의 되어야 한다.     
        
그래서 일반적으로 operator[] 함수는 const 함수와 일반함수가 동시에 정의된다.        
    
***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
