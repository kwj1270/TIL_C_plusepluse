11 연산자 오버로딩2
=======================
# 1. 반드시 해야 하는 대입 연산자의 오버로딩
## 1.1. 객체간 대입 연산의 비밀: 디폴트 대입 연산자      
기존에 생성된 객체를 가지고 기존의 객체를 초기화 하는 경우에 사용된다.        
```opertator=()``` 으로 따로 메소드를 정의하지 않으면 디폴트 대입 연산자가 호출된다. 
    
![cpp68](https://user-images.githubusercontent.com/50267433/75637660-3f364a00-5c6b-11ea-9fa2-efa322484945.PNG)   
    
디폴트 대입 연산자는 멤버 변수에 따라 알맞게 정의 되어진다.     
    
## 1.2. 디폴트 대입 연산자의 문제점
만약 멤버 변수에서 포인터 변수로 참조를 하는 경우 디폴트 대입 연산자를 사용할 경우 문제점이 생긴다.     
멤버가 복사가 되는 것이므로 참조하는 주소값을 복사가 되어지고       
이로 인해 2개의 객체의 멤버가 같은 메모리를 가리키는 얕은 복사의 문제가 발생한다.      
    
![cpp71](https://user-images.githubusercontent.com/50267433/75637793-d7343380-5c6b-11ea-8d0e-091afcfede5e.PNG)   
     
이를 해결하고자 깊은 복사를 위한 복사 생성자와 유사하게 코드를 작성해주면 된다.  
단, 차이점은 메모리 누수를 위한 멤버 변수 delete 구문이 추가 되었다.  
   
## 1.3. 상속 구조에서의 대입 연산자 호출   
디폴트 대입 연산자는 기초 클래스의 대입 연산자를 호출해준다.(이 부분은 매우 똑똑하다)         
![cpp69](https://user-images.githubusercontent.com/50267433/75639744-a527cf00-5c75-11ea-93cb-8d8e8a3593d2.PNG)      
그러니 명시적으로 대입 연산자를 정의하게 되면, 기초 클래스의 대입 연산자 호출도 별도로 명시해주어야 한다.       

## 1.4. 이니셜라이저의 성능 향상 도움
이니셜라이저를 이용해서 멤버를 초기화하면, 함수 호출의 수를 1회 줄일 수 있다.     
    
![cpp70](https://user-images.githubusercontent.com/50267433/75639790-d56f6d80-5c75-11ea-936f-68b89dfb1514.PNG)   
       
생성자 내에서 ```=```를 사용하는 것도 연산자 오버로딩 함수를 실행 한것으로 총 2번의 함수 호출이 일어난 것이다.       
반대로 이니셜라이저를 사용하면 생성과 동시에 초기화를 진행하므로 1회만 호출된 것으로 볼 수 있다.        
      
*** 
# 2. 배열의 인덱스 연산자 오버로딩 
## 2.1. 배열보다 나은 배열 클래스     
배열보다 배열 클래스의 나은점은 개발자가 기능을 추가적으로 구현할 수 있다는 점이다.      
![cpp72](https://user-images.githubusercontent.com/50267433/75640711-4fedbc80-5c79-11ea-81e4-f1439efb26d5.PNG)       
예를 들면 배열의 범위를 넘어선 인덱스 값을 사용하더라도        
포인터 연산으로 진행되기에 에러 없이 실행 된다는 문제점이 있다.       
  
하지만 이러한 문제점을 배열 클래스를 이용하여 해결해 줄 수 있다.     
배열 클래스를 정의할 때 경계 검사 코드를 추가로 삽입하여 이러한 문제점을 해결할 수 있다는 것이다.         
  
그리고 이러한 배열 클래스는 ```[]```연산자 오버로딩을 작성하여 배열과 유사하게 이용할 수 있다.      
      
```
arrObject[2];
```
연산자 오버로딩을 통해서 다음과 같이 배열처럼 접근이 가능한 객체의 모습이다.      

```
arrObject.operator[](2);
```
이는 위와 같이 해석이 된다.  

```
int operator[] (int index){......}
```   
때문에 ```[]```연산자는 아래와 같이 오버로딩 해야한다.    
   
## 2.2. 배열 클래스의 예
![cpp73](https://user-images.githubusercontent.com/50267433/75641125-8e37ab80-5c7a-11ea-87ef-7cb2790e3159.PNG)
앞서 설명한 경계 검사를 추가해주었다.    
   
**경계 검사**
```
if(idx < 0 || idx >= arrlen){
    cout<<"Array index out of bound Exception"<<endl;
    exit(1);
}
```
## 2.3. 배열 클래스의 안전성 확보 
배열은 저장소의 일종이고, (데이터를 저장했는데 이를 복사하는 것은 철학에 안맞음)       
저장소에 저장된 데이터는 유일성이 보장되어야 하기 때문에 ```배열 = 배열``` 복사는 불가능 하다.        
               
배열 객체를 대상으로 하는 복사와 관련된 연산은 모두 불가능하게 해야 할 필요도 있다.  
(물론 상황에 따라서 복사를 해야 된다면 따로 방법을 마련해두자)                
```
SampleClassArray arr = cpy    ->    X   : 복사 생성자  
arr = cpy1                    ->    X   : 대입 연산자
```   
     
![cpp74](https://user-images.githubusercontent.com/50267433/75641737-a27ca800-5c7c-11ea-80bc-9c1f7bdacf69.PNG)   
      
     
이렇듯 배열을 복사하거나 생성시 할당 초기화가 되지 않도록 처리를 해주고자     
복사와 관련된 연산의 제한을 위해서 복사 생성자와 대입 연산자를 ```private``` 로 선언한다.  

## 2.4. const 함수를 이용한 오버로딩의 활용   
함수의 const 유무는 함수 오버로딩의 조건이 된다.      
       
![cpp75](https://user-images.githubusercontent.com/50267433/75642235-1cf9f780-5c7e-11ea-9e6e-1b88189e1c7c.PNG)  
      

const 함수를 정의하는 경우는 단순히 함수 호출을 위해서이다.  
const 배열 클래스에서 인덱스를 이용하여 값을 얻더라도 변경이 불가능 해야하므로 const 메소드가 정의되어야 한다.    
  
반대로 일반 배열 클래스에서는 이러한 인덱스를 이용해서 값을 변경하는 일이 주된 목적일 것이다.    
그렇기에 const 함수가 아닌 다른 일반 함수를 정의 해주어야 하며       
반환형을 참조자 형태로 주어 실제 메모리 접근인 call-by-reference가 진행되도록 해주어야 한다.           
(일반 자료형으로 하면 복사가 이루어지기 때문에 값을 변경해도 변경이 일어나지 않는다.)            
       
결론을 말하자면 일반적으로 operator[] 함수는 const 함수와 일반함수가 동시에 정의하자.        
     
## 2.5. 객체의 저장을 위한 배열 클래스1          
객체의 저장 방법은 2가지이다.           
첫번째 방법은 객체를 통째로 저장하는 방법이고            
두번째 방법은 객체의 주소 값을 저장하는 방법이 있다.      
         
![cpp76](https://user-images.githubusercontent.com/50267433/75642905-824ee800-5c80-11ea-8d05-cdeb59ea2a69.PNG)     
        
위 그림은 객체를 통째로 저장하는 방법이다.          
일반 자료형이 아닌 클래스를 대상으로 정의된 배열 클래스이다.           
생성할 때 ```new 내부 클래스[길이]```를 이용해서 생성한다.       
        
이렇게 객체를 통째로 저장을 한다는 것은       
```객체 = 객체```형태이지만 사실상 ```클래스 포인터 변수 = 클래스 객체```이므로          
```멤버 대 멤버```복사 연산자가 진행되어 저장되는 것이다. (같은 자료형을 띄우고 있기에)      
    
무슨 뜻이냐면 같은 ```자료형의 포인터 변수 = 객체```이기에 복사 연산이 진행되는 것이다.   
## 2.6. 객체의 저장을 위한 배열 클래스2
![cpp77](https://user-images.githubusercontent.com/50267433/75650481-4f651e00-5c99-11ea-9295-1219ba2d1cb1.PNG)
      
위 그림은 객체의 주소 값을 저장하는 방법이다.                   
여기서는 더블 포인터를 이용해서 객체를 단순히 참조하는 형태로 만들었기에 복사 연산자를 진행하지 않는다.               
그렇기에 연산이 1회 줄어들고 복사 연산자에 관해 신경쓰지 않아도 되니 더 많이 사용하는 방법이다.   
   

***  
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
