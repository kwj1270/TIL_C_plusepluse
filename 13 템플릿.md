13 템플릿
=======================
# 1. 템플릿에 대한 이해와 함수 템플릿
## 1.1. 함수를 대상으로 템플릿 이해하기 
함수는 매개변수의 자료형에 따라서 오버로딩을 할 수 있는 조건이 성립된다.    
하지만 이에 대해서 일일이 코드를 작성해준다는 것은 매우 불필요한 일이며      
기본 자료형이 아닌 사용자 정의 자료형도 존재하기에 이를 수용할 범위는 매우 넓어진다.      
템플릿은 이러한 불편함을 해결하고자 등장했다.        
        
![cpp93](https://user-images.githubusercontent.com/50267433/76312639-cee89200-6316-11ea-8ab7-309930899d41.PNG)     
           
템플릿은 특정 자료형에 얽매이지 않는 메소드를 정의하기 위한 문법이다.             
우리는 이러한 템플릿 선언으로 알맞는 메소드를 생성하여 호출하는 것이다.          
(템플릿은 함수와 엄연히 다르다 그렇기에 '함수 템플릿'이라는 명칭을 사용한다.)        
     
**함수 템플릿**
```
template <typename T>
T Function(T val1, T val2)
{
      .     .     .     .
}
```

## 1.2. 컴파일러가 생성하는 템플릿 기반 함수
```
template <typename T>
T Function(T val1, T val2)
{
      .     .     .     .
}
```
![cpp94](https://user-images.githubusercontent.com/50267433/76313067-94cbc000-6317-11ea-82f2-a22d78f3fbc7.PNG)    
      
앞서 정의한 템플릿을 기준으로 자료형에 맞는 메소드를 생성한다.            
```
int Function<int>(int val1, int val2)
{
      .     .     .     .
}
```  
여기서 중요한 점은 메소드의 형태를 보게되면 ```<자료형>```을 가지는데     
이는 일반 메소드와 템플릿 메소드를 구분하는 중요한 기준점으로 사용되므로                     
명확히 나타내주기 위해서 템플릿 메소드를 정의하게 된다면 기술해주는 편이 좋다.              
     
## 1.3. '메소드템플릿'을 이용하여 '템플릿메소드' 생성하여 호출하기  
```
int Function<int>(int val1, int val2)
{
      .     .     .     .
} 
```
앞서 메소드템플릿을 통해 생성되는 템플릿메소드는 위와 같은 형태를 띄우고 있다.       
    
**그렇다면 메소드를 호출하는 형태도 ```<자료형>```을 붙여주어야 하나?**     
정답만 말하자면 **YES** 즉, ```메소드<자료형>()```으로 호출해주는 것이 좋다.     
    
![cpp95](https://user-images.githubusercontent.com/50267433/76313791-fcced600-6318-11ea-96a1-69eda775bff5.PNG)        
     
우선 ```<자료형>```을 생략한 상태로도 호출이 가능하다.          
이는 기본 자료형일 경우에 해당되는 이야기이며 대개 기본 자료형이 매개변수로 들어가면 연관되기 때문이다.       
     
하지만 앞서 말했듯이 명확하지도 않으며 사용자 정의 자료형도 존재하므로          
이럴 경우에는 무조건 적으로 ```메소드<자료형>()```으로 호출해주는 것이 좋다.       
       
## 1.4. 둘 이상의 자료형에 대해 템플릿 선언하기  
우선 이번장에서는 앞서 말했던 ```메소드<자료형>()```으로 호출하는 이유에 대해서 설명하고 있다.  
![cpp96](https://user-images.githubusercontent.com/50267433/76314104-8aaac100-6319-11ea-90a4-0daf30230b6c.PNG)      
                   
기존 선언과 차이점은         
```template <typename T>```과 달리     
```template <class T1, class T2>``` class 키워드를 이용하여 사용을 한다.       
그리고 템플릿에 관해서도 매개변수를 템플릿형이 아닌 기본 자료형으로 선언을 해도 된다는 것을 나타낸다.   
                   
이 예제를 통해서 알 수 있는 점은 기존에 ```<자료형>```을 생략하게 된다면    
컴파일러 입장에서는 ```double```로만 정의되어 있는 템플릿 메소드를 호출할 것인지  
아니면 위의 예제를 호출할지를 명확히 구분할줄 모르므로 우리는 ```메소드<자료형>()```으로 호출하는 것이 좋다.  
    
## 1.5. 함수 템플릿의 특수화 
                            
![cpp97](https://user-images.githubusercontent.com/50267433/76316687-58e82900-631e-11ea-8c37-c575ab2cd656.PNG)    
  
위 그림에서 보면 문자열이 들어갔을 경우 기존 템플릿에 정의된 메소드의 절차를 수행하기가 힘들다.       
특수화는 이러한 예외상황을 해결하기 위해 사용된다.                
    
![cpp98](https://user-images.githubusercontent.com/50267433/76317462-96998180-631f-11ea-8c47-bbdef55cf4af.PNG)   
    
**특수화 선언 방법**  
```
template <>
자료형 메소드이름(매개변수)
{
        .       .       .       .       
}
```
특수화는 생각보다 어렵지 않다.      
메소드템플릿으로 생성될 템플릿메소드를 먼저 정의해준다는 식으로 이해를 하면 된다.            
단 ```template <>```으로 지정하듯이 ```typename```이나 ```class```는 기술하지 않는다.        
         
위 코드에서는 문자열을 수정하는 경우와 그렇지 않은 경우 2가지로 나뉘어질 수 있어 const 선언 유무로 2번 정의했다.              
              
![cpp99](https://user-images.githubusercontent.com/50267433/76318059-7918e780-6320-11ea-8571-b6bc2c2c220e.PNG)       
       
기존에 작성된 방식은 특수화 하는 자료형의 정보를 생략했지만         
앞서 말했듯이 명확히 작성하는 것이 좋은 방법이기에 명시하도록 하자      
   
      
***  
# 2. 클래스 템플릿     
## 2.1. 클래스 템플릿의 정의      
![cpp100](https://user-images.githubusercontent.com/50267433/76318710-779bef00-6321-11ea-889f-1e91b865000a.PNG)        
클래스 템플릿은 한마디로 비유하자면 과일 상자이다.                      
그리고 그 과일상자에 들어가는 과일들은 템플릿이다.           
무슨 뜻이냐면 어떠한 과일을 담을 과일 상자로 담으면 과일 상자에는 해당 과일만 들어 갈 것이다.        
        
클래스 템플릿도 마찬가지이다.            
클래스에 특정 템플릿을 지정해주게 된다면 특정 자료형을 지정해주면 클래스 내에서 해당 자료형을 사용할 수 있다.       
        
## 2.2. 클래스 템플릿의 선언과 정의의 분리     
![cpp101](https://user-images.githubusercontent.com/50267433/76319216-3ce68680-6322-11ea-8ac2-a07d8ce85443.PNG)     
       
```h 파일```과 ```c 파일``` 양측에서 ```template T```를 사용하므로 템플릿 선언을 해주어야한다.        
하지만 뒤에 나올 내용이지만 혼란을 이야기할 수 있기에 먼저 말을 하겠다.   
``` 
템플릿은 헤더 파일과 클래스 파일로 나뉘어서 정의하면 안된다.
```
우선은 정의가 가능하다는 가정하에 이야기를 해보려 하는 것이다.        
         
클래스 템플릿에 정의되어 있는 메소드템플릿이라 하여 ```클래스::메소드``` 형태로 호출을 하게 된다면              
이는 단순히 클래스내의 일반 메소드를 호출하기에 메소트템플릿이 호출이 되지 않는다.               
              
그렇기에  ```클래스<자료형>::메소드```의 형태로 호출을 진행해주어야 템플릿메소드를 호출한다.          
   
## 2.3. 헤더파일과 소스파일의 구분     
![cpp102](https://user-images.githubusercontent.com/50267433/76319880-30aef900-6323-11ea-9e51-ceae9cfbf393.PNG)    
앞서 말했듯이 ```c 파일```과 ```h 파일```로 나누면 오류가 발생한다 그 이유는?        
       
![cpp103](https://user-images.githubusercontent.com/50267433/76320016-62c05b00-6323-11ea-81a8-a635621988ff.PNG)   
   
컴파일러는 1개의 파일을 기준으로 코드를 수행한다.(물론 링커라는 친구도 존재하지만....)   
템플릿은 c 언어의 구조체와 비슷하게 작동을 한다.   
즉, ```h 파일```에 선언된 메소드를 ```c 파일```에서 정의를 했지만     
컴파일러가 코드를 컴파일 할 때 ```h 파일```의 정보만 읽어들어서 템플릿메소드의 정의는 읽지 못한다.   
(링커가 동작 안하는건지 이런건 조금 더 자세히 알아봐야겠다.)   

그렇기에 우리는 
헤더 파일에 클래스 템플릿을 정의할 때 정의부를 같이 기술하던가     
```c 파일```이더라도 이를 include 해야 된다.               
