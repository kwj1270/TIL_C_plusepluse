05 복사 생성자
=======================
# 1. '복사 생성자'와의 첫 만남
**기본 자료형**
```
int a = 10;
int b = a; (O)
```
기본 자료형 같은 경우 변수를 이용하여 대입을 할 수 있다.      
        
**객체 자료형**
```
Class classA; 
Class classB = classA; (X)
```
하지만 객체는 객체 변수를 이용하여 대입을 진행할 수 없다.          
이는 객체의 내부구조가 다양하게 있으므로 경우의 수가 너무 많아져 갑의 대입을 진행할 수 없다.     
   
쉽게 결정할 수 없는 일이기 때문에 C++은  대입 연산시 발생하는 동작을 개발자가 직접 정의하라고 말하고 있다.  
(대입 연산에 대한 결과를 우리에게 위임하는 것이라고 보면 된다.)   

C++ 은 재미있는 것이 초기화랑 대입을 구분지어서 정의할 수 있다.
```
ABC abc;

//1)
ABC abc2 = abc;

//2)
ABC abc2;
abc2 = abc;
```    
1. 1번은 객체 생성과 동시에 초기화를 진행해주는 것이다.      
2. 2번은 객체를 생성하고 새로운 객체를 대입해주는 것이다.(즉 이미 생성된 객체간의 대입이다)    
     
복사 생성자는 1번 동작에 대한 결과를 정의하는 것이 복사 생성자를 정의하는 것이다.     
(즉, 생성과 동시에 초기화를 진행했을 때의 방법을 정의하는 것이다)     
    
## 1.1. C++ 스타일의 초기화  
**C 스타일**
```
int num = 20;
int &ref = num;
```
**C++ 스타일**
```
int num(20);
int &ref(num)
```
두 문장은 실제로 동일한 문장으로 해석된다.         
즉, ```int num = 20;```은```int num(20)```과 같고,      
```int &ref = num;```은 ```int &ref(num)```과 같다는 것이다.      
실은 C스타일의 문법이 C++스타일의 문법으로 변환되어 계산된다고 이해하면 된다.         
그리고 이는, C++ 스타일로 초기화를 진행하게 된다면 생성자가 호출되어 대입되는 것을 알 수가 있다.      
     
다른 예로 들어보면 내부 동작을 정확히 이해할 수가 있다.      
   
**SoSimple**
```
class SoSimple
{
        private:
                int num1;
                int num2;
        public:
                SoSimple(int n1, int n2) : num1(n1), num2(n2)
                {}
                void ShowSimpleData()
                {
                        cout<<num1<<endl;
                        cout<<num2<<endl;
                }
}
```
**main**
```
int main(void)
{
        SoSimple sim1(15,20);
        SoSimple sim2=sim21;
        sim2.ShowSimpleData();
        return 0;
}
``` 
이 과정에서 SoSimple에 관한 멤버 변수는 존재하지 않는다.           
하지만 결과로서는 ```15 20```이 출력 되었다.         
그럼 어떻게 이렇게 된 것일까?         
                        
![cpp24](https://user-images.githubusercontent.com/50267433/74527639-92b95000-4f69-11ea-9284-1bfd4695244e.PNG)  
                        
**C++에서는 동일한 클래스를 매개변수를 받는 생성자를 복사 생성자라고 한다**          
또한 동일한 클래스를 매개변수로 받는 생성자를 정의하지 않은 경우 디폴트 복사 생성자가 호출된다.             
   
![cpp26](https://user-images.githubusercontent.com/50267433/74527891-373b9200-4f6a-11ea-898c-5ccec404ee84.PNG)
    
디폴트 복사 생성자는 동일한 클래스의 객체가 들어오면 같은 변수끼리의 짝을 맞춰서 복사하여 할당을 해준다.             
**복사하여 할당해주는 이유는 원본이 변경이 되지 않아야 하가 때문이고 const 선언의 이유도 이와 마찬가지이다.**   
           
![cpp25](https://user-images.githubusercontent.com/50267433/74527694-b5e3ff80-4f69-11ea-89d2-3beb7c159a39.PNG)
      
위와 같이 직접 정의해준다면 사용자가 원하는 방식으로 복사 생성자를 정의할 수 있다.         
 
## 1.2. 키워드 explicit
```
SoSimple sim2 = sim1 ----> SoSimple sim2(sim1);
```   
기존 객체 초기화 과정은 묵시적 형 변환을 통해 이루어졌다.    
하지만 **explicit**으로 선언을 하게 된다면 이러한 묵시적 형 변환을 막을 수 있다.    
     
**1번 복사 생성자**   
```
explicit SoSimple(const SoSimple & copy)
        : num1(copy.num1), num2(copy.num2)
{
        // empty
}
```
**2번 일반 생성자**   
```
class AAA
{
private:
        int num;
public:
        explicit AAA(int n) : num(n) {}
        . . . . .
};
```
이렇게 클래스의 복사 생성자나 일반 생성자를 explicit로 선언하면    
```Class class = 3``` 이런식으로 생성은 불가능하고 ```Class class(3)``` 이렇게 생성은 가능하다.     

***
# 2. '깊은 복사'와 '얕은 복사'
## 2.1. 디폴트 복사 생성자의 문제      
![cpp27](https://user-images.githubusercontent.com/50267433/74532277-2262fc80-4f72-11ea-8573-13205fcd8656.PNG)   
            
**일반 생성자만 정의되어 있다.**   
```
Person(char * myname, int myage) 
{       
        int len = strlen(myname)+1;
        name = new char[len];
        strcpy(name, myname);
        age = myage;
}
```
위 코드는 직접 비교하는 코드가 아니라 맨 처음 생성했을 때 실행되는 코드이다.      
이제 객체 대입을 진행하게 되면 클래스의 생성자는 **위 코드밖에 없으니**     
디폴트 복사 생성자가 생성되어 호출이 된다.      
   
디폴트 복사 생성자는 짝이 맞는 멤버 변수끼리 매칭시켜서 값을 복사해서 할당해준다.       
여기서 문제점이 1번 객체와 같이 포인터로 어떠한 메모리를 가리키고 있으면      
복사된 2번 객체도 마찬가지로 1번 객체가 가리키고 있는 메모리를 가리키고 있다.         
        
여기서 문제점은 만약 1번이나 2번에서 가리키고 있는 메모리를 해제하게 된다면      
나머지 객체는 해당 메모리에 접근할 수 없게 되고 이는 객체간의 종속성을 매우 높이는 위험한 일이다.        
그리고 이러한 복사가 진행되는 구조를 **얕은 복사**라고 한다.         
   
## 2.2. 깊은 복사 정의하기   
   
![cpp28](https://user-images.githubusercontent.com/50267433/74532880-a7024a80-4f73-11ea-978a-f531e2bb9d72.PNG)
     
**깊은 복사 코드**   
```
Person(const Person& copy) : age(copy.age)
{
        name = new char[strlen(copy.name)+1];
        strcpy(name, copy.name)
}
```
복사 생성자를 직접 정의해줌으로써 위에서 말한 얕은 복사에 대한 문제점을 방지할 수 있다.        
코드를 보면 참조자 copy로 직접 객체를 불러오지만 ```참조자.변수```구조를 이용하여        
메모리 접근이 아닌 값을 초점으로 반환을 하여 이러한 얕은 복사를 예방하였다.        
      
## 2.3. 정리 
```
1.      -> 생성자로 생성
        -> 객체 = 객체 진행
        -> 복사 생성자가 없어 디폴트 복사 생성자 호출
        -> 멤버 변수가 포인터이므로 메모리/변수타입 가져옴
        -> 이는 기존 객체가 가리키는 것과 동일한 메모리를 가리키게 됨
        
2.      -> 생성자로 생성
        -> 객체 = 객체 진행
        -> 복사 생성자 호출되어 같은 클래스의 객체를 매개변수로 가져옴
        -> 매개변수의 정보를 이용하여 새로운 char[] 만들고 값을 복사해옴(메모리 복사x)
        -> 이는 기존 객체가 가리키는 것과 다른 메모리를 가리키게 됨
```
  
***
# 3. 복사 생성자의 호출 시점       
## 3.1. 복사 생성자의 호출되는 시점
   
![cpp29](https://user-images.githubusercontent.com/50267433/74535577-6c031580-4f79-11ea-900c-4a9ef2fa03e1.PNG)   
   
만약에 A 클라스 객체를 매개변수로 받는 메소드가 있다고 가정을 해보자
```
A function(A aclass){
        reutrn aclass;
}
```
그리고 이러한 메소드를 호출하는 구문도 필요하다
```
A a;
A aa = function(a);
```
이때 진행되는 과정은 아래에 기술하겠다.
```
1. A aclass = a 형태가 되므로 복사 생성자를 호출하는 복사가 이루어진다.  
2. 복사가 된 aclass를 리턴을 진행을 하는데 aclass는 지역변수이다.
3. 사실 return을 진행하면 해당 값과 똑같은 메모리 구조를 만들고 retunrn 하려는 대상을 대입하는 구조이기에
4. A ??? = aclass가 진행되고 여기서 또 복사 생성자를 호출하는 복사가 이루어진다.   
5. aa = ?? 구조가 되었고 이는 또 복사 생성자를 호출하는 복사가 이루어진다.  
```
     
![cpp30](https://user-images.githubusercontent.com/50267433/74535666-a8cf0c80-4f79-11ea-991f-fec49becabe6.PNG)
   
위 그림에서는 매개변수의 복사와 오른쪽 동작 절차를 이해하자 (특히 복사 생성자를 호출하는 것을)   
     
![cpp31](https://user-images.githubusercontent.com/50267433/74535772-e59b0380-4f79-11ea-8012-99225ed79dea.PNG)   
          
위 그림에서는 반환과 바로 재사용에 관한 절차를 이해하자       
참고로 처음 SimpleFuncOb는 새로운 객체를 생성하지만 복사한 객체를 대상으로 진행하기에        
마지막에 showData를 진행해도 전혀 다른 객체이므로 변화를 주지 못했다.(위 복사객체는 라인이 끝나면 소멸된다.)      
         
## 3.2. 반환할 때 만들어진 객체의 소멸 시점       
![cpp32](https://user-images.githubusercontent.com/50267433/74536016-8ab5dc00-4f7a-11ea-94ff-0969b1f1418b.PNG)   
         
앞서 봤듯이 반환된 객체를 따로 저장할 공간을 지정해주지 않았기에 해당 객체는 라인이 끝나면 소멸된다.  
그리고 이렇게 한 라인에만 존재하는 데이터를 임시 객체라 한다.    
이렇게 반환된 값을 참조자나 포인터를 이용할 경우 계속 사용할 수 있게 된다.   
그리고 이러한 반환된 값도 일단 익명 변수에 반환되는 것이므로 const 참조자를 사용할 수 있다.  

### 3.1.1. 내용1
```
내용1
```
