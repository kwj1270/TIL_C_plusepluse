05 복사 생성자
=======================
# 1. '복사 생성자'와의 첫 만남
**기본 자료형**
```
int a = 10;
int b = a; (O)
```
기본 자료형 같은 경우 변수를 이용하여 대입을 할 수 있다.      
        
**객체 자료형**
```
Class classA; 
Class classB = classA; (X)
```
하지만 객체는 객체 변수를 이용하여 대입을 진행할 수 없다.          
이는 객체의 내부구조가 다양하게 있으므로 경우의 수가 너무 많아져 갑의 대입을 진행할 수 없다.     
   
쉽게 결정할 수 없는 일이기 때문에 C++은  대입 연산시 발생하는 동작을 개발자가 직접 정의하라고 말하고 있다.  
(대입 연산에 대한 결과를 우리에게 위임하는 것이라고 보면 된다.)   

C++ 은 재미있는 것이 초기화랑 대입을 구분지어서 정의할 수 있다.
```
ABC abc;

//1)
ABC abc2 = abc;

//2)
ABC abc2;
abc2 = abc;
```    
1. 1번은 객체 생성과 동시에 초기화를 진행해주는 것이다.      
2. 2번은 객체를 생성하고 새로운 객체를 대입해주는 것이다.(즉 이미 생성된 객체간의 대입이다)    
     
복사 생성자는 1번 동작에 대한 결과를 정의하는 것이 복사 생성자를 정의하는 것이다.     
(즉, 생성과 동시에 초기화를 진행했을 때의 방법을 정의하는 것이다)     

## 1.1. C++ 스타일의 초기화  
**C 스타일**
```
int num = 20;
int &ref = num;
```
**C++ 스타일**
```
int num(20);
int &ref(num)
```
두 문장은 실제로 동일한 문장으로 해석된다.         
즉, ```int num = 20;```은```int num(20)```과 같고,      
```int &ref = num;```은 ```int &ref(num)```과 같다는 것이다.      
실은 C스타일의 문법이 C++스타일의 문법으로 변환되어 계산된다고 이해하면 된다.         
그리고 이는, C++ 스타일로 초기화를 진행하게 된다면 생성자가 호출되어 대입되는 것을 알 수가 있다.      
     
다른 예로 들어보면 내부 동작을 정확히 이해할 수가 있다.      
   
**SoSimple**
```
class SoSimple
{
        private:
                int num1;
                int num2;
        public:
                SoSimple(int n1, int n2) : num1(n1), num2(n2)
                {}
                void ShowSimpleData()
                {
                        cout<<num1<<endl;
                        cout<<num2<<endl;
                }
}
```
**main**
```
int main(void)
{
        SoSimple sim1(15,20);
        SoSimple sim2=sim21;
        sim2.ShowSimpleData();
        return 0;
}
``` 
이 과정에서 SoSimple에 관한 멤버 변수는 존재하지 않는다.           
하지만 결과로서는 ```15 20```이 출력 되었다.         
그럼 어떻게 이렇게 된 것일까?         
                        
![cpp24](https://user-images.githubusercontent.com/50267433/74527639-92b95000-4f69-11ea-9284-1bfd4695244e.PNG)  
                        
**C++에서는 동일한 클래스를 매개변수를 받는 생성자를 복사 생성자라고 한다**          
또한 동일한 클래스를 매개변수로 받는 생성자를 정의하지 않은 경우 디폴트 복사 생성자가 호출된다.             
디폴트 복사 생성자는 동일한 클래스의 객체가 들어오면 같은 변수끼리의 짝을 맞춰서 복사하여 할당을 해준다.             
**복사하여 할당해주는 이유는 원본이 변경이 되지 않아야 하가 때문이고 const 선언의 이유도 이와 마찬가지이다.**   
         
![cpp25](https://user-images.githubusercontent.com/50267433/74527694-b5e3ff80-4f69-11ea-89d2-3beb7c159a39.PNG)
      
위와 같이 직접 정의해준다면 사용자가 원하는 방식으로 복사 생성자를 정의할 수 있다.         

      
      
     









### 1.1.1. 내용1
```
내용1
```
## 1.2. 소 주제
### 1.2.1. 내용1
```
내용1
```

***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
