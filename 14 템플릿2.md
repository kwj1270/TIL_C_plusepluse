14 템플릿2
=======================
# 1. 탬플릿 심화
## 1.1. Point 클래스 템플릿과 배열 클래스 템플릿 
![cpp104](https://user-images.githubusercontent.com/50267433/76391060-f3457c80-63b1-11ea-8070-3a66477b2c4b.PNG)    
      
일반적인 배열 클래스 템플릿이다.        
자료형에 따라 선언만 다르게 해주면 다양한 자료형의 클래스를 생성해준다.         
        
**그렇다면 포인터 자료형도 가능한가?** 정답은 **가능하다.**    
```
Point<int>* iarr(50);
```   
      
우리는 앞서 클래스를 대상으로 클래스 템플릿을 작성했다.       
그렇다면 이러한 클래스를 멤버로 가지는 클래스를 사용한다면 어떻게 되겠는가?           
즉, 어떤 템플릿 클래스를 대상으로 하는 템플릿 클래스를 말하는 것이다.          
사실 어렵게 생각할 필요는 없다.         
그저 우리가 선언하던데로 ```<>```에 클래스 템플릿을 넣어주면 되기 때문이다.           
          
```
BoundCheckArray<Point<int>*> iarr(50);
```
    
하지만 이러한 표현 방법보다는 typedef를 이용한 것이 가독성이 좋기에 이를 활용하는 것도 좋은 방법이다.  
    
```
typedef Point<int>* POINT_PTR
BoundCheckArray<POINT_PTR> iarr(50);
```

## 1.2. 템플릿 클래스 대상의 함수선언과 friend 선언     
![cpp105](https://user-images.githubusercontent.com/50267433/76391703-6a2f4500-63b3-11ea-8a8b-f0001a0d541d.PNG)     
        
우선 템플릿 클래스 또한 매개변수 및 반환형으로 지정하여 사용도 가능하고       
이러한 함수를 대상으로도 friend 선언을 할 수 있다.       
즉, 템플릿 클래스도 일반 자료형과 차별을 받지 않는다는 것이다.          
       
friend 선언은 선언 대상에 대해서 현재 클래스의 private 접근을 허락해주는 것이다.       
위 코드에서 보면 해당 메소드에 firend 선언을 했으므로       
외부에서 해당 메소드를 정의할 때 private 멤버 변수를 접근할 수 있도록 해준다.     
      
***
# 2. 클래스 템플릿 특수화   
## 2.1. 클래스 템플릿 특수화  
![cpp106](https://user-images.githubusercontent.com/50267433/76392787-9e0b6a00-63b5-11ea-84d4-65b1429823a2.PNG)
     
* 클래스 템플릿을 특수화 하는 이유는        
특정 자료형으로 생성된 객체에 대해, 구분이 되는 다른 행동 양식을 적용하기 위함이다.        
   
* 함수 템플릿을 특수화하는 방법과 이유, 그리고 클래스 템플릿을 특수화하는 방법과 이유는 동일하다.  
    
## 2.2. 클래스 템플릿의 부분 특수화   
![cpp107](https://user-images.githubusercontent.com/50267433/76392934-e1fe6f00-63b5-11ea-9568-abd0c62729fb.PNG)
     
만약 클래스 템플릿에 자료형이 2개일 경우는 어떻게 하는가?          
답은 간단하다 우리는 ```template <typename T1, typename T2>```을 정의해주면 된다.           
         
그런데 이중에서 전부가 아닌 일부분만 특수화로 지정을 하고 싶으면 어떻게 해야하는가?         
눈치를 챘듯이 부분 템플릿을 사용해주면 된다.              
                
부분 템플릿은 일부분에 관해서만 템플릿을 사용하기에 나머지 부분은 자료형을 기술해주면 된다.           
단, 그전에 전체 템플릿이 존재해야 한다는 조건이 있다.         
그리고 일부분에 관해서 템플릿을 사용하므로  ```template <....>```을 알맞게 기술해주어여 한다.             
            
그리고 이러한 부분 특수화에 대해서는 우선순위가 존재하는데            
예를 들면 ```Mysimple<char, int>```를 대상으로 한다면       
        
1. 일반적인 클래스 템플릿     
2. ```<char, int>``` 전체 특수화 템플릿     
3. ```<T1, int>``` 부분 특수화 템플릿    
           
순으로 작동을 하게 되며 여기서는 2번이 수행될 것이다.          
      
그리고 1번은 클래스 템플릿 2번은 템플릿 클래스여서        
3번도 템플릿 클래스로 오해하기 쉽지만 사실 **클래스 템플릿**이다.        
     
이유는 ```<int, double>```이 있다고 가정시에 이를 기준으로 할 경우 1번이 수행되지만       
이를 뒤집어서 즉, ```<double, int>```로 사용할 경우 3번이 수행되고 이에 관한 클래스가 생성된다.             
      
      
***
# 3. 템플릿 인자  
## 3.1. 템플릿 매개변수에는 변수의 선언이 올 수 있습니다.   
![cpp108](https://user-images.githubusercontent.com/50267433/76397940-58539f00-63bf-11ea-8002-3cf0c67330c4.PNG)             
템플릿 ```<>```에는 매개변수 처럼 인자를 넘겨줄 수 있고 이를 클래스 내에서 활용할 수도 있다.                 
        
그리고 이렇게 인자가 다른 값으로 생성된 클래스들은 똑같은 구조를 하고 있음에도     
**서로 다른 자료형의 클래스로 인식되고 연관성이 완전히 제거 된다**     
   
## 3.2. 템플릿 매개변수는 디폴트 값 지정도 가능합니다.     
![cpp109](https://user-images.githubusercontent.com/50267433/76398272-efb8f200-63bf-11ea-8e34-a6ab103ce6c7.PNG)      
템플릿 매개변수는 디폴트값도 지정할 수 있다.         
     
       
***
# 4. 템플릿과 static      
## 4.1. 함수 템플릿과 static 지역변수            
변수명은 같지만 자료형이 다르다는 것은 결국 각자에 맞는 메모리를 참조해야 한다는 것이다.   
        
![cpp110](https://user-images.githubusercontent.com/50267433/76398377-1d9e3680-63c0-11ea-82d5-398fb2face65.PNG)      
          
위 예제에서는 메소드내의 지역변수에 대해서 말하고 있다.     
메소드내의 지역변수라도 static 일 경우 메모리에 남아 있기도 하고         
예제에서 나타내고자 한 템플릿 함수 별로 독립적인 것을 나타내고 있다.      
       
## 4.2. 클래스 템플릿과 static 멤버 변수   
같은 구조로 생성된 템플릿 클래스의 객체들이라도 static 변수에 관해서는 따로 존재하게 된다.          
이유는 앞서 설명했듯이 자료형이 다르다는 것은 결국 각자에 맞는 메모리를 참조해야 한다는 것이다.       
   
![cpp111](https://user-images.githubusercontent.com/50267433/76398960-26433c80-63c1-11ea-90aa-678987b53106.PNG)   
   
클래스 템플릿에서 ```static```을 사용한다는 것은 멤버변수로 사용한다는 것이기에     
이는 외부에서 초기화를 진행해주어야 한다.  

## 4.3. ```template<typename T>``` VS ```template<>```
![cpp112](https://user-images.githubusercontent.com/50267433/76399167-833ef280-63c1-11ea-81bc-5aa9bd3bd450.PNG)      
앞서 클래스 템플릿에서 ```static``` 멤버 변수를 초기화 할 때 아래와 같은 구문을 사용했다.     
    
```  
template<>
long SimpleStaticMem<long>::mem=5;
```   
사실 클래스에서도 사용했지만 영향 범위가 '클래스 내'이기에             
클래스 외부에서 static 변수를 정의하는 구문에서도 이와 같은 선언이 필요하다.    
      
그리고 단순 초기화 구문에서는 ```T```가 없기에 선언 안해도 될 것 같지만      
정의를 하지 않을 경우 일반 클래스에 접근을 하는 것과 차이가 없으므로       
정의를 해주는 것이 좋다.       
     
