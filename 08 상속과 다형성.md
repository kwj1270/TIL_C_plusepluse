08 상속과 다형성
=======================
# 1. 객체 포인터의 참조 관계
일반 사람하고 축구선수가 있다.         
축구선수는 사람을 상속받은 았다.         
이때 축구선수는 사람되고 축구선수도 될 수 있다.         
      
이러한 현실세계의 관점도 프로그램에서 적용될 수가 있다.                 
즉, 사람 포인터 변수로 축구선수 객체를 가리킬 수 있고              
이를 다시 말하면 **부모 클래스 포인터 변수로 자식 객체를 참조할 수 있다.**     
      
단, 이러한 관점에서 사람 포인터를 통해 가리 킨 것이므로 사람 멤버만 접근이 가능하다.        
             
## 1.1. 객체의 주소 값을 저장하는 객체 포인터 변수     
c++ 에서, AAA형 포인터 변수는 AAA객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다.      
(객체의 주소 값으 저장할 수 있다.)        
  
```
class Student : public Person
{
  . . . . . 
}
class PartTimeStudent : public Student
{
  . . . . . 
}
```
```
Person * ptr = new Person();
Person * ptr = new Student();
Person * ptr = new PartTimeStudent();

Student * ptr = new Student();
Student * ptr = new PartTimeStudent();

PartTimeStudent * ptr = new PartTimeStudent();
```
앞서 말했듯이 포인터 변수의 자료형에 관한 멤버만 사용할 수 있다.        
그런데 Student 같은 경우로 보자면 Person 과 Student 멤버를 사용할 수 있는 것이다.      
           
그리고 이렇게 부모 클래스가 여러 관련된 자식 클래스들을 가리킬 수 있는 것을 **다형성**이라 부른다.           
      
## 1.2. 다형성과 이를 이용한 Contoller 사용의 이점   
  
* 고용인 : Employee
* 정규직 : PermanentWorker
* 영업직 : SaleWorker
* 임시직 : TemporaryWorker   
      
![cpp33](https://user-images.githubusercontent.com/50267433/74602112-e0a89200-50e8-11ea-9c17-7b5a82e280ac.PNG)      
        
모든 클래스의 객체를 Employee 클래스의 객체로 간주할 수 있는 기반을 마련          
            
컨트롤러 클래스 입장에서는 모든 객체를 Employee 객체로 간주해도 문제가 되지 않는다.           
### 1.2.1. Contoller
```
class EmployeeHandler
{
private:
      Employee * empList[50];
      int empNum;
public:
      EmployeeHandler(): empNum(0)
      { }
      
      void AddEmployee(Employee * emp)
      {
            empList[empNum++] = emp;
      }
      
      void ShowAllSalaryInfo() const
      {
            /* Permanent에 한해서만 가능하니 에러가 난다
            for(int i = 0 ; i < empNum; i++)
            {
                  empList[i] -> ShowSalaryInfo();
            }
            */
      }
      void SHowTotalSalary() const
      {     
            /* Permanent에 한해서만 가능하니 에러가 난다
            int sum = 0;
            for(int i = 0 ; i < empNum; i++)
            {
                  sum += empList[i]->GetPay();
            }
            cout<<"Salary Sum: "<<sum<<endl;
            */
      }
      ~EmployeeHandler()
      {
            for(int i=0; i < empNum;i++)
            {
                  delete empList[i];
            }
      }
}
```    
이렇게 최상위 클래스인 Employee를 기준으로 Controller를 작성하게 되면        
이를 상속받는 모든 객체의 흐름을 1개의 Controller를 이용해서 처리할 수 있다.        
(물론 각 클래스마다의 특징의 처리를 진행하기는 어렵지만 공통된 기능을 처리 할 수 있다.)        
   
### 1.2.2. 클래스들과 오버라이딩   
![cpp34](https://user-images.githubusercontent.com/50267433/74602266-36ca0500-50ea-11ea-9be0-96a8e3fc0224.PNG)         
![cpp35](https://user-images.githubusercontent.com/50267433/74602279-60832c00-50ea-11ea-8107-bdb03849b010.PNG)     
![cpp36](https://user-images.githubusercontent.com/50267433/74602291-7395fc00-50ea-11ea-88ad-43eb9d2ca564.PNG)   
  
SalesWorker의 코드를 보게 되면 오버라이딩이란 것이 존재한다.    
오버라이딩은 **상속받은 메소드를 다시 재정의 한다는 것으로**       
         
PermanentWorker 클래스에서 이미 정의된 GetPat 함수와 ShowSalayInfo함수의 구조를 가져와서       
SalesWorker에 맞게끔 재정의하는 것을 볼 수 있다.            
      
원래는 상속을 했을 경우 상속한 멤버들을 제약 없이 호출할 수 있지만        
Override를 진행하여 이름이 겹쳐졌기에 이전에 사용한 메소드를 사용하려면        
```클래스::메소드()```로 사용을 해야 한다.                 
이렇게 사용하지 않을 경우 현재 클래스의 메소드를 호출하는 것이 되기 때문이다.        
     
***  
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
