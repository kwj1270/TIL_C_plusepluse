08 상속과 다형성
=======================
# 1. 객체 포인터의 참조 관계
일반 사람하고 축구선수가 있다.         
축구선수는 사람을 상속받은 았다.         
이때 축구선수는 사람되고 축구선수도 될 수 있다.         
      
이러한 현실세계의 관점도 프로그램에서 적용될 수가 있다.                 
즉, 사람 포인터 변수로 축구선수 객체를 가리킬 수 있고              
이를 다시 말하면 **부모 클래스 포인터 변수로 자식 객체를 참조할 수 있다.**     
      
단, 이러한 관점에서 사람 포인터를 통해 가리 킨 것이므로 사람 멤버만 접근이 가능하다.        
             
## 1.1. 객체의 주소 값을 저장하는 객체 포인터 변수     
c++ 에서, AAA형 포인터 변수는 AAA객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다.      
(객체의 주소 값으 저장할 수 있다.)        
  
```
class Student : public Person
{
  . . . . . 
}
class PartTimeStudent : public Student
{
  . . . . . 
}
```
```
Person * ptr = new Person();
Person * ptr = new Student();
Person * ptr = new PartTimeStudent();

Student * ptr = new Student();
Student * ptr = new PartTimeStudent();

PartTimeStudent * ptr = new PartTimeStudent();
```
앞서 말했듯이 포인터 변수의 자료형에 관한 멤버만 사용할 수 있다.        
그런데 Student 같은 경우로 보자면 Person 과 Student 멤버를 사용할 수 있는 것이다.      
           
그리고 이렇게 부모 클래스가 여러 관련된 자식 클래스들을 가리킬 수 있는 것을 **다형성**이라 부른다.           
      
## 1.2. 다형성과 이를 이용한 Contoller 사용의 이점   
  
* 고용인 : Employee
* 정규직 : PermanentWorker
* 영업직 : SaleWorker
* 임시직 : TemporaryWorker   
      
![cpp33](https://user-images.githubusercontent.com/50267433/74602112-e0a89200-50e8-11ea-9c17-7b5a82e280ac.PNG)      
        
모든 클래스의 객체를 Employee 클래스의 객체로 간주할 수 있는 기반을 마련          
            
컨트롤러 클래스 입장에서는 모든 객체를 Employee 객체로 간주해도 문제가 되지 않는다.           
### 1.2.1. Contoller
```
class EmployeeHandler
{
private:
      Employee * empList[50];
      int empNum;
public:
      EmployeeHandler(): empNum(0)
      { }
      
      void AddEmployee(Employee * emp)
      {
            empList[empNum++] = emp;
      }
      
      void ShowAllSalaryInfo() const
      {
            /* PermanentWorker에 한해서만 가능하니 에러가 난다
            for(int i = 0 ; i < empNum; i++)
            {
                  empList[i] -> ShowSalaryInfo();
            }
            */
      }
      void SHowTotalSalary() const
      {     
            /* PermanentWorker에 한해서만 가능하니 에러가 난다
            int sum = 0;
            for(int i = 0 ; i < empNum; i++)
            {
                  sum += empList[i]->GetPay();
            }
            cout<<"Salary Sum: "<<sum<<endl;
            */
      }
      ~EmployeeHandler()
      {
            for(int i=0; i < empNum;i++)
            {
                  delete empList[i];
            }
      }
}
```    
이렇게 최상위 클래스인 Employee를 기준으로 Controller를 작성하게 되면        
이를 상속받는 모든 객체의 흐름을 1개의 Controller를 이용해서 처리할 수 있다.        
(물론 각 클래스마다의 특징의 처리를 진행하기는 어렵지만 공통된 기능을 처리 할 수 있다.)        
   
### 1.2.2. 클래스들과 오버라이딩   
![cpp34](https://user-images.githubusercontent.com/50267433/74602266-36ca0500-50ea-11ea-9be0-96a8e3fc0224.PNG)         
![cpp35](https://user-images.githubusercontent.com/50267433/74602279-60832c00-50ea-11ea-8107-bdb03849b010.PNG)     
![cpp36](https://user-images.githubusercontent.com/50267433/74602291-7395fc00-50ea-11ea-88ad-43eb9d2ca564.PNG)   
  
SalesWorker의 코드를 보게 되면 오버라이딩이란 것이 존재한다.    
오버라이딩은 **상속받은 메소드를 다시 재정의 한다는 것으로**       
         
PermanentWorker 클래스에서 이미 정의된 GetPat 함수와 ShowSalayInfo함수의 구조를 가져와서       
SalesWorker에 맞게끔 재정의하는 것을 볼 수 있다.            
      
원래는 상속을 했을 경우 상속한 멤버들을 제약 없이 호출할 수 있지만        
Override를 진행하여 이름이 겹쳐졌기에 이전에 사용한 메소드를 사용하려면        
```클래스::메소드()```로 사용을 해야 한다.                 
이렇게 사용하지 않을 경우 현재 클래스의 메소드를 호출하는 것이 되기 때문이다.        
     
또 재미있는점은 ```ShowSalaryInfo()```는 오버라이딩 전과 완전히 똑같이 생겼지만 이렇게 오버라이딩을 한 이유는   
PermanentWorker 클래스 내에서 ```ShowSalaryInfo()```를 실행하는 것이므로        
PermanentWorker의 ```getPay()```를 호출하는 것으로 동작하기 때문에 오버라이딩을 진행했다.      
    
***  
# 2. 가상 함수     
## 2.1. 기초 클래스의 포인터 객체를 참조하면,   
```
C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때,   
포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.
따라서 포인터형에 해당하는 클래스의 멤버에만 접근이 가능하다.   
```
    
![cpp37](https://user-images.githubusercontent.com/50267433/74623233-274cc980-5187-11ea-9134-2c5be4855bda.PNG)
       
       
코드를 보면 객체의 자료형을 기준으로 판단하기에   
   
1. 다형성으로 인한 포인터 변수의 참조는 가능하지만 자식 객체의 멤버에 접근 못하며       
2. 자식클래스 포인터 변수가 부모 클래스 객체 할당에 대한 에러를 표시할 수 있다.     
         
![cpp38](https://user-images.githubusercontent.com/50267433/74623438-ff119a80-5187-11ea-858d-c07d71396ba7.PNG)   
     
## 2.2. 함수의 오버라이딩과 포인터 형      
   
![cpp39](https://user-images.githubusercontent.com/50267433/74623576-76dfc500-5188-11ea-831f-cebf3842f6f4.PNG)   

C++ 과 자바의 차이점이 이러한 오버라이딩에서 나타는데     
우선 자바 같은 경우 오버라이딩이 될 경우 참조한 객체의 메소드를 호출하지만  
C++ 에서는 포인터형의 메소드를 호출하게 된다.    
     
즉 Third 객체를 First가 참조하게 되면    
자바는 Third 객체가 오버라이딩한 메소드가 호출 되는 것이고   
C++은 First의 오버라이딩이 되지 않은 메소드가 호출되는 것이다.   

           
## 2.3. 가상함수   
C++에서도 자바처럼 객체의 함수를 사용하고 싶을 때는 어떻게 할까?   
그럴 때 사용하는 것이 바로 **가상함수**이다.    
       
![cpp40](https://user-images.githubusercontent.com/50267433/74623844-8c092380-5189-11ea-83a1-1dc18ae87d2a.PNG)   
       
문법은 간단하다 오버라이딩 대상이 되는 함수들에 ```virtual``` 이라는 키워드를 작성해주면 된다.    
(virtual은 대상이 되는 클래스 내의 멤버에도 정의하고 호출문에도 정의해야 한다.)   
이렇게 작성이 되면 객체가 가리키는 마지막 함수를 호출한다.     
(만약 Third 에서 오버라이딩 안한다면? -> Second 객체의 함수를 호출할 것이다.)         
               
현 상황에서의 EmployeeManager 클래스는 모든 객체를 Employee 객체로 간주한다.         
따라서 호출하는 함수도 Employee 객체의 멤버 함수이다.        
하지만 이러한 가상함수의 특성을 이용해서 앞서 작성한 Employee를 수정해서 해결할 수 있다.        
   
## 2.4. 급여관리 확장성 문제의 해결과 상속의 이유         
        
![cpp41](https://user-images.githubusercontent.com/50267433/74624388-8b718c80-518b-11ea-88ae-6d7acfdd56b9.PNG)     
        
GetPay 함수와 ShowSalaryInfo 함수를 Virtual로 선언하였으므로,     
EmployeeHandler가 호출하는 함수는 Employee 클래스의 멤버 함수일지라도     
실제 호출되는 함수는 각 포인터가 가리키는 객체의 마지막 오버라이딩 함수이다.           
       
이렇듯 상속은 연관된 일련의 클래스들에 대헤 공통의 규약을 적용할 수 있게 해준다.      
      
*** 
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
