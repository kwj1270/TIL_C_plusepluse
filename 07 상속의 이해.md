07 상속의 이해
=======================
# 1. 상속에 들어가기에 앞서
## 1.1. 문제의 제시를 위한 시나리오의 도입
프로그램 전체 기능을 처리를, 프로그램의 흐름을 담당하는 클래스를 가리켜 컨트롤 클래스라 한다.     
(클래스의 멤버를 이용해가지고 기능을 만들고 이러한 기능들을 모아놓은 집합체라 볼 수 있다.)     
     
## 1.2. 문제의 제시   
기존에 작성된 코드는 **정규직**만을 처리하는 코드였다.   
이에 발전하여 **영업직**, **임시직** 또한 처리할 수 있는 클래스를 작성하고자 한다.   

이 문제는 단순히 영업직과 임시직에 해당하는 클래스의 추가로 끝나지 않는다.       
컨트롤 클래스인 EmployeeHandler클래스의 대대적인 변경으로 이어진다.       
    
좋은 코드는 요구사항의 변경 및 기능의 추가에 따른 변경이 최소화 되어야 한다.   
그리고 이를 위한 해결책을 상속이 사용된다.    
(우리는 클래스를 새로 정의하는 것 보다 코드량을 줄일 수 있게 된다.)    
    
***
# 2. 상속의 문법적인 이해
부모 클래스 A클래스를 상속받는 B클래스가 존재한다고 가정할 때      
B클래스는 자신의 멤버 뿐만 아니라 A클래스의 멤버도 같이 포함하고 있다.       
    
그런데 여기서 궁금한 점이 B클래스의 생성자는 A클래스의 멤버도 초기화를 진행하는 것이 말이 되는가 이다.  
기본적으로 생성자와 소멸자는 자신의 클래스에서 호출하는 것을 원칙으로 하고 있다.     
(각 클래스의 생성자는 해당 클래스의 멤버를 가장 잘 초기화 시켜주는 함수이기 때문이다.)    
      
## 2.1. 상속의 방법과 그 결과.  
```
class UnivStudent : public Person
{
private:
  char major[50];
public:
  UnivStudent(char * myname, int myage, char * mymajor) // Person 클래스의 멤버값도 받는다
    : Person(myage, myname) // Person의 생성자를 호출하여 초기화 진행
  {
    strcpy(major, mymajor); // 현재 클래스 초기화 
  }  
  
  void WhoAreYou() const
  {
    WhatYourName(); // Person 멤버의 클래스
    HowOldAreYou(); // Person 멤버의 클래스
    cout<<"My major is " <<major<<endl<<endl;
  }
};
```
자식 클래스는 부모 클래스의 멤버를 포함하므로 특별한 네임스페이스 없이 사용할 수 있다.
    
Person 클래스를 public 상속한다.  
자식 클래스는 이니셜라이저르 통해 부모 클래스의 생성자를 이용해서 부모 클래스 멤버를 초기화를 해주어야하며    
이를 위해서 자식 클래스의 생성자는 부모 클래스의 멤버변수를 초기화 할 값을 인자로 받아야 한다.    
사실 부모 클래스의 멤버를 포함하기에 자식 클래스에서 초기화를 진행해 줄 수도 있지만  
private 선언이 되어 있는 멤버 변수는 자식클래스도 외부로 취급해 접근을 못하니 부모 생성자를 이용해야 된다.    
        
만약 자식 클래스에서 부모 클래스의 멤버를 초기화를 진행해주지 않고 싶다면   
부모 클래스에서는 void 생성자를 정의 해주어야 한다.   
  
**자식 클래스의 객체 생성 과정 1**        
   
1. 메모리 공간 할당
2. 자식 클래스의 생성자 호출
3. 부모 클래스의 생성자의 호출 및 실행
4. 자식 클래스의 생성자 실행
      
**자식 클래스의 객체 생성 과정 2**
   
1. 메모리 공간 할당
2. 자식 클래스의 생성자 호출
3. 이니셜라이저를 통한 부모 클래스의 생성자 호출이 명시 되어있지 않으니 void 생성자 호출 및 실행
4. 자식 클래스의 생성자 실행    
   
## 2.2. 유도 클래스 객체의 소멸과정    

```
~SoDerived()
{
  cout<<"~SoDrived() : "<<derivNum<<endl;
}
```
위 소멸자는 자식 클래스의 소멸자인데 여기서 알 수 있는 점은 **부모 클래스의 소멸자는 명시하지 않아도 된다.**            
    
자식 클래스의 소멸자가 실행된 이후에 부모 클래스의 소멸자가 실행된다.   
스택기반으로 생성된 객체의 소멸 순서는 생성 순서와 반대이다.  
         
***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
