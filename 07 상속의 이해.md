07 상속의 이해
=======================
# 1. 상속에 들어가기에 앞서
## 1.1. 문제의 제시를 위한 시나리오의 도입
프로그램 전체 기능을 처리를, 프로그램의 흐름을 담당하는 클래스를 가리켜 컨트롤 클래스라 한다.     
(클래스의 멤버를 이용해가지고 기능을 만들고 이러한 기능들을 모아놓은 집합체라 볼 수 있다.)     
     
## 1.2. 문제의 제시   
기존에 작성된 코드는 **정규직**만을 처리하는 코드였다.   
이에 발전하여 **영업직**, **임시직** 또한 처리할 수 있는 클래스를 작성하고자 한다.   

이 문제는 단순히 영업직과 임시직에 해당하는 클래스의 추가로 끝나지 않는다.       
컨트롤 클래스인 EmployeeHandler클래스의 대대적인 변경으로 이어진다.       
    
좋은 코드는 요구사항의 변경 및 기능의 추가에 따른 변경이 최소화 되어야 한다.   
그리고 이를 위한 해결책을 상속이 사용된다.    
(우리는 클래스를 새로 정의하는 것 보다 코드량을 줄일 수 있게 된다.)    
    
***
# 2. 상속의 문법적인 이해
부모 클래스 A클래스를 상속받는 B클래스가 존재한다고 가정할 때      
B클래스는 자신의 멤버 뿐만 아니라 A클래스의 멤버도 같이 포함하고 있다.       
    
그런데 여기서 궁금한 점이 B클래스의 생성자는 A클래스의 멤버도 초기화를 진행하는 것이 말이 되는가 이다.  
기본적으로 생성자와 소멸자는 자신의 클래스에서 호출하는 것을 원칙으로 하고 있다.     
(각 클래스의 생성자는 해당 클래스의 멤버를 가장 잘 초기화 시켜주는 함수이기 때문이다.)    
      
## 2.1. 상속의 방법과 그 결과.  
```
class UnivStudent : public Person
{
private:
  char major[50];
public:
  UnivStudent(char * myname, int myage, char * mymajor) // Person 클래스의 멤버값도 받는다
    : Person(myage, myname) // Person의 생성자를 호출하여 초기화 진행
  {
    strcpy(major, mymajor); // 현재 클래스 초기화 
  }  
  
  void WhoAreYou() const
  {
    WhatYourName(); // Person 멤버의 클래스
    HowOldAreYou(); // Person 멤버의 클래스
    cout<<"My major is " <<major<<endl<<endl;
  }
};
```
자식 클래스는 부모 클래스의 멤버를 포함하므로 특별한 네임스페이스 없이 사용할 수 있다.
    
Person 클래스를 public 상속한다.  
자식 클래스는 이니셜라이저르 통해 부모 클래스의 생성자를 이용해서 부모 클래스 멤버를 초기화를 해주어야하며    
이를 위해서 자식 클래스의 생성자는 부모 클래스의 멤버변수를 초기화 할 값을 인자로 받아야 한다.    
사실 부모 클래스의 멤버를 포함하기에 자식 클래스에서 초기화를 진행해 줄 수도 있지만  
private 선언이 되어 있는 멤버 변수는 자식클래스도 외부로 취급해 접근을 못하니 부모 생성자를 이용해야 된다.    
        
만약 자식 클래스에서 부모 클래스의 멤버를 초기화를 진행해주지 않고 싶다면   
부모 클래스에서는 void 생성자를 정의 해주어야 한다.   
  
**자식 클래스의 객체 생성 과정 1**        
   
1. 메모리 공간 할당
2. 자식 클래스의 생성자 호출
3. 부모 클래스의 생성자의 호출 및 실행
4. 자식 클래스의 생성자 실행
      
**자식 클래스의 객체 생성 과정 2**
   
1. 메모리 공간 할당
2. 자식 클래스의 생성자 호출
3. 이니셜라이저를 통한 부모 클래스의 생성자 호출이 명시 되어있지 않으니 void 생성자 호출 및 실행
4. 자식 클래스의 생성자 실행    
   
## 2.2. 유도 클래스 객체의 소멸과정    

```
~SoDerived()
{
  cout<<"~SoDrived() : "<<derivNum<<endl;
}
```
위 소멸자는 자식 클래스의 소멸자인데 여기서 알 수 있는 점은 **부모 클래스의 소멸자는 명시하지 않아도 된다.**            
    
자식 클래스의 소멸자가 실행된 이후에 부모 클래스의 소멸자가 실행된다.   
스택기반으로 생성된 객체의 소멸 순서는 생성 순서와 반대이다.  
         
***
# 3. protected 선언과 3가지 형태의 상속.  
## 3.1. protected로 선언된 멤버가 허용하는 접근의 범위      
```
private < protected < public
```
protected는 private와 달리 상속관계에서의 접근을 허용한다.    
예를 들면 private 함수가 있다면 자식 클래스는 해당 함수를 호출할 수가 없다.   
단, protected는 상속관계에서는 허용하기에 protected 함수로 정의 되어있으면 호출할 수 있다.    
    
## 3.2. 3가지 형태의 상속      
**public 상속**
```
class derived : public Base
{
     .    .    .    .    .
}
```
접근 제어 권한을 그대로 상속한다.     
단, private는 접근 불가로 상속한다.     
   
**protected 상속**
```
class derived : protected Base
{
     .    .    .    .    .
}
```
protected 보다 접근의 범위가 넓은 멤버는 protected로 상속한다.   
단, private는 접근 불가로 상속한다.     
     
**private 상속**
```
class derived : private Base
{
     .    .    .    .    .
}
```
private 보다 접근의 범위가 넓은 멤버는 private로 상속한다.      
단, private는 접근 불가로 상속한다.       
          
***
# 4. 상속을 위한 조건    
## 4.1. 상속의 기본 조건인 IS-A 관계의 성립   
```
전화기 -> 무선 전화기
컴퓨터 -> 노트북 컴퓨터
```
```
무선 전화기는 일종의 전화기입니다.  
노트북 컴퓨터는 일종의 컴퓨터입니다.  
```
무선 전화기는 전화기의 기본 기능에 새로운 특성이 추가된 것이다.    
노트북 컴퓨터는 컴퓨터의 기본 기능에 새로운 특성이 추가된 것이다.     
이렇게 아래로 내려오는 과정일 수록 객체가 더 구체화 된다고 볼 수 있다.    
```
무선 전화기 is a 전화기
노트북 컴퓨터 is a 컴퓨터
```
이렇듯 is-a 관계는 논리적으로 상속을 기반으로 표현하기에 매우 적절하다.  
```
전화기 is a 무선 전화기
컴퓨터 is a 노트북 컴퓨터
```      
반대로 배치를 해보자면 모든 전화기는 무선 전화기가 아니므로 이러한 관계는 성립하지 않는다.      
is-a 관계에서는 a 해당하는 객체가 부모 객체가 되어야 한다.        
  
## 4.2. HAS-A 관계를 상속으로 구성하려면   
```
Police has a Gun

경찰은 총을 소유한다. 
```
```
class Police : public Gun 
{
     .    .    .    .    .
}
```
has a 관계도 상속으로 구현은 가능하다.         
하지만 이러한 경우 Police와 Gun은 강한 연결성을 띄게 된다.       
따라서 총을 소유하고 있지 않은 경찰이나, 다른 무기를 소유하는 경찰을 표현하기가 쉽지 않아진다.       
             
그렇기 때문에 **has-a 관계를 가지고 상속을 진행하기는 조금 어렵다.**            
(이러한 has-a 관계는 다중 상속이 필요한 경우가 많아서 단점이 많아진다.)                      
(참고로 자바는 단일 상속만 되고 C++은 다중상속을 지원해준다.)          
      
## 4.3. HAS-A 관계는 포함으로 표현한다.
**Police**
```
class Police
{
private: 
     int handcuffs;
     Gun * pistol;
public:
     Police(int bnum, int bcuff) // bnum은 총알 갯수
          : handcuffs(bcuff)
     {
          if(bnum > 0)
          {
               pistol = new Gun(bnum);
          }
          else
          {
               pistol = NULL;
          }
     }     
     .    .    .    .    .    .    .
}
```
has-a 관계를 포함의 형태로 표현하면,     
두 클래스간 연결성은 낮아지며, 변경 및 확장이 용이해진다.     
      
즉, 총을 소유하지 않은 경찰의 표현이 쉬워지고,        
추가로 무기를 소유하는 형태로의 확장도 간단해진다.     
      
  
