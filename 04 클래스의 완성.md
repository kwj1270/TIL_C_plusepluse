04 클래스의 완성
=======================
# 1. 정보 은닉
정보 은닉 : 클래스 멤버를 해당 클래스를 제외한 외부 클래스에서의 접근을 불허하겠다.     
## 1.1. 정보 은닉의 이해        
멤버변수의 외부접근을 허용하면, 잘못된 값이 저장되는 문제가 발생할 수 있다.          
따라서 멤버 변수의 외부접근을 막게 되는데, 이를 가리켜 정보은닉이라 한다.         
     
![cpp12](https://user-images.githubusercontent.com/50267433/74315011-e1c08300-4db9-11ea-8780-5061f99d8d2a.PNG)      
          
위 그림에서 Point 클래스의 멤버 변수에 대해서 어떠한 제한도 지정해줄 수 없고        
외부에서 접근해서 원치 않는 범위의 값을 넣어주어서 에러를 일으킬 수 있다.         
      
이렇듯 접근제어를 외부허용으로 하면 여러 문제를 불러일으킬 수 있다.      
우리는 이러한 문제점이 일어나지 않게 빈도의 수를 최소한으로 줄여주도록 해야한다.      
           
그러기 위해서 처음으로 생각할 수 있는 것은 **함수를 이용해 값을 초기화 하는 것이다.**    
함수를 이용할 경우 값에 대한 처리를 진행할 수 있고(높고,낮음 등)        
함수를 사용하지 않고 접근할 경우 매번 값을 할당 해줄 때마다 조심히 처리를 해주어야 하기 때문이다.        
          
정보은닉은 함수를 통해서 안정적으로 접근할 수 있는 길을 터주는 것이다.      
더하여 외부에서 접근시 빈번히 발생할 수 있는 실수를 막아버리기 위해서 멤버 변수를 private로 선언해주는 것이다.       
                 
참고로 위 그림에서 재밌는 점은 class 키워드로 선언했지만 외부에서 멤버 변수에 값을 할당한다.           
이는 class는 기본 private이지만 그림에서 보면 public으로 선언했기에 외부에서 접근이 가능했던 것이다.       
그리고 또한 클래스의 객체는 다른 클래스의 멤버가 될 수 있다는 점도 알 수 있다.(단 원본이 아닌 값 복사이다.)             
         
![cpp13](https://user-images.githubusercontent.com/50267433/74319561-82b33c00-4dc2-11ea-9577-d5e4f3e555f8.PNG)        
          
함수만 한번 잘 정의되면 잘못된 접근을 원친적으로 차단할 수 있다.(외부 접근도 막아주면)              
그리고 이런 함수의 이름 명칭을 지정하는데 암묵적 규칙이 있다.      
       
* 값을 할당해주는것은 ```set변수명()```     
* 값을 가져오는 것은 ```get변수명()```     
             
## 1.2. const 함수              
**멤버함수의 const 선언**
```
int getX() const;
int getY() const;
void ShowRecInfo() const;
```
const 함수 내에서는 동일한 클래스에 선언된 멤버변수의 값을 변경하지 못한다.        
get은 단순히 값만 불러오도록 정의하지만 혹시나 하는 안정성을 추가하기 위해서 const를 추가해서 사용한다.     
     
**const 함수의 일반 함수 접근 불가**
```
int GetNum()
{
     return num;
}
void ShowNum() const
{
     cout<<GetNum()<<endl;
}
``` 
const 함수는 const가 아닌 함수를 호출하지 못한다.              
즉, 간접적인 멤버의 변경 가능성까지 완전히 차단한다.       
     
**const 함수의 const 함수 접근 가능**
```
void InitNum(const EasyClass &easy){
     num = easy.GetNum();
}
```
const로 상수화 된 객체라도 const 멤버 함수가 아니면 호출이 안된다     
하지만 const로 상수화 된 객체를 대상으로는 const 멤버함수도 호출이 가능하다.      
     
## 1.3. 소스코드                   
**point.h**
```
#ifndef __POINT_H_
#define __POINT_H_

class Point
{
	int x; 
	int y;    
public:
	Point(const int &xpos, const int &ypos);
	int GetX() const;
	int GetY() const;
	bool SetX(int xpos);
	bool SetY(int ypos);
};

#endif
```   
    
**point.c**
```
#include <iostream>
#include "Point.h"
using namespace std;

Point::Point(const int &xpos, const int &ypos)
{
	x=xpos;
	y=ypos;
}

int Point::GetX() const {return x;}
int Point::GetY() const {return y;}

bool Point::SetX(int xpos)
{
	if(0>xpos || xpos>100)
	{
		cout<<"벗어난 범위의 값 전달"<<endl;
		return false;
	}

	x=xpos;
	return true;
}	
bool Point::SetY(int ypos)
{
	if(0>ypos || ypos>100)
	{
		cout<<"벗어난 범위의 값 전달"<<endl;
		return false;
	}

	y=ypos;
	return true;
}
```
**rectangle.h**
```
#include <iostream>
#include "Point.h"
using namespace std;

Point::Point(const int &xpos, const int &ypos)
{
	x=xpos;
	y=ypos;
}

int Point::GetX() const {return x;}
int Point::GetY() const {return y;}

bool Point::SetX(int xpos)
{
	if(0>xpos || xpos>100)
	{
		cout<<"벗어난 범위의 값 전달"<<endl;
		return false;
	}

	x=xpos;
	return true;
}	
bool Point::SetY(int ypos)
{
	if(0>ypos || ypos>100)
	{
		cout<<"벗어난 범위의 값 전달"<<endl;
		return false;
	}

	y=ypos;
	return true;
}
```
**rectangle.c**
```
#include <iostream>
#include "Rectangle.h"
using namespace std;

Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
			:upLeft(x1, y1), lowRight(x2, y2)
{
	// empty
}

void Rectangle::ShowRecInfo() const
{
	cout<<"좌 상단: "<<'['<<upLeft.GetX()<<", ";
	cout<<upLeft.GetY()<<']'<<endl;
	cout<<"우 하단: "<<'['<<lowRight.GetX()<<", ";
	cout<<lowRight.GetY()<<']'<<endl<<endl;
}
```
**main**
```
#include<iostream>
#include "Point.h"
#include "Rectangle.h"
using namespace std;

int main(void)
{

	Rectangle rec(1, 1, 5, 5);
	rec.ShowRecInfo();
	return 0;
}
```
 
***
# 2. 캡슐화
캡슐화 : 대상과 관련이 있는 모든 것들을 해당 클래스에 담아 놓는 것
캡슐화의 어려운 점은 어디까지 관련이 있는가에 대한 기준이 없기 때문이다.   
  
캡슐화를 왜 잘 해야하는가 하면     
각 클래스마다 서로 관련된 내용들이 뒤죽박죽 섞여있으면 어떤 클래스의 변경은 다른 클래스의 변경을 유발할 수 있다.        
그렇기에 임의의 변경시에 다른 프로그램에 영향을 주는 것을 최소화하고자 캡슐화를 잘해야 한다.        
즉, 클래스 별로 독립성을 최대한 해주어 변경이나 확장에 대해서 대응이 가능한 상태로 클래스 수준을 높이는 것이다.      




## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
