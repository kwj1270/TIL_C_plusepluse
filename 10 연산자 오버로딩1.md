10 연산자 오버로딩1
=======================
스킬이 아닌 이해를 기준으로 학습을 하자     
# 1. 연산자 오버로딩의 이해와 유형         
예를 들어 Point 클래스를 참조하는 변수 p1 와 p2가 있다고 가정했을 시     
```
p1 + p2
```
위와 같이 ```객체 + 객체``` 구조는 원래는 성립되지 않는 구조이다.            
우선 ```C++```에서는 연산자에 매칭되는 함수를 실행시키고 그 함수에 피연산자를 인자로 넘긴다.   
```
예)
p1 + p2 -> p1.operator+(p2);
        -> operator+(p1, p2);
```   
함수는 ```멤버 함수```와 ```전역 함수```로 2가지 형태로 존재하는데          
멤버 함수라고 한다면 ```p1 operator+() p2``` 구조는 ```p1.operator+(p2)```이라고 볼 수 있다.    
**그리고 C++에서는 이러한 연산이 들어 왔을 때 처리하는 메소드를 오버라이딩 해줄 수 있다.**        
  
또한 전역함수로도 정의를 할 수 있다.   
이럴 경우  ```operator_plus(p1,p2)```구조로 실행이 된다.        
   
재미있는 점은 멤버함수나 전역함수로 정의하면 알맞은 구조로 알아서 실행해준다.     
   
이제 왜 '연산자 오버로딩'이란 이름을 사용했을까?       
이유는 간단하다 양 측에 있는 피 연산자들의 타입에 따라 실행 되는 메소드가 다르기 때문이다.  

## 1.1. operator+ 라는 이름의 함수
![cpp53](https://user-images.githubusercontent.com/50267433/74907793-68e3ab80-53f7-11ea-8bd4-fc571e2d0638.PNG)    
Point 클래스의 ```public:``` 에 위와 같이 메소드를 정의하게 되면     
![cpp54](https://user-images.githubusercontent.com/50267433/74907542-e824af80-53f6-11ea-8133-54912833fddc.PNG)      
외부에서 ```Pointer 변수 + 피연산자``` 연산을 진행을 할 수 있게 된다.        
         
단, 이러한 동작은 함수호출의 특정 규칙으로 인해 동작하는 것이므로 규칙을 이해하는 것이 중요하다   
    
## 1.2. 연산자를 오버로딩 하는 2가지 방법  
![cpp55](https://user-images.githubusercontent.com/50267433/74907970-e7404d80-53f7-11ea-949f-2716870dc248.PNG)      
이번에는 전역함수 방식으로 정의를 해놓은 것이다.      
friend 선언으로 Point 클래스의 private 멤버에 접근을 가능토록 만들어   
인자로 받아들인 값들의 멤버들에 접근하여 연산을 진행토록 하였다.   
   
![cpp56](https://user-images.githubusercontent.com/50267433/74907983-edcec500-53f7-11ea-8d5a-f0a45c79b18e.PNG)   
하는 일은 결과적으로 같다.    
    
## 1.3. 오버로딩이 불가능한 연산자의 종류        
![cpp57](https://user-images.githubusercontent.com/50267433/74908332-f2e04400-53f8-11ea-8056-b3bb30ad969c.PNG)
   
* 오버로딩이 되면 C++ 의 문법 자체를 뒤흔들 수 있는 연산자는 오버로딩을 허용하지 않았다.   
* 전역함수로 오버로딩한다는 것은 종속적이지 않다는 것인데 그렇지 않은 연산자들도 존재한다.     
     
## 1.4. 연산자를 오버로딩 하는데 있어서의 주의사항  
![cpp58](https://user-images.githubusercontent.com/50267433/74908339-fa9fe880-53f8-11ea-8ba9-c9d7c0f23674.PNG)

1. 본래의 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다!   
2. 연산자의 우선순위와 결합성은 바뀌지 않는다.  
3. 매개변수의 디폴트 값 설정이 불가능하다. ```(default 자료형 변수 = 값) -> X ```  
4. 연산자의 순수 기능까지 빼앗을 수는 없다.   

4번 같은 경우는 무슨 얘기냐면 
```
int operator+(const int num1, const int num2)
{
        return num1*num2;    
}  
```
언뜻 보면 ```*```으로 리턴한게 문제라 생각이 들지만 (물론 이것도 1번 해당 사항이여서 하지 말자)        
```3+4``` 같은 기본 자료형을 이용한 연산자는 이미 결정이 되어있으므로 정의하면 안된다.       
즉, 우리는 기본 자료형을 대상으로는 오버로딩이 불가능하다.     
      
***
# 2. 단항 연산자 오버로딩   
단항 연산자도 마찬가지로 operator를 사용한다.  
```
val.operator++()
operator++(val)
```
하지만 단항 연산자에서 애매한 점은 ```전위``` 와 ```후위```로 나뉘어 진다는 것이다.         
        
그래서 이를 구분할 기준이 필요했고 C++에서는 **후위 증가에 ```int``` 넣어주기로 했다.**        
          
후위 증가가 맴버 함수였을 경우에는 ```int```를 매개변수로 넣어준다.                   
```
operator++(int)
{
        .       .       .       .       
}
```
매개변수에 ```int```를 준것은 오버로딩 조건에 맞추어 오버로딩 시키기 위해서이다.              
          
그러면 전역변수는 어떻게 할까?      
```    
operator++(자료형 변수, int)
{
        .       .       .       .       
}
```
전역 변수는 인자로 값을 하나 받을 것이다.       
그리고 맴버 변수와 마찬가지로 ```int```를 뒤에 선언해주어 오버로딩이 되게끔 해준다.         
           
## 2.1. 증가, 감소 연산자의 오버로딩  
### 2.1.1. 전위 연산자   
![cpp59](https://user-images.githubusercontent.com/50267433/74913448-fe853800-5403-11ea-8647-84b343be916e.PNG)     
          
```
Point& operator++()
{
        xpos+=1;
        ypos+=1;
        return *this;
}
```
참고로 위와 같은 코드는 return 으로 자기 자신을 리턴한다   
그렇다면 왜 이렇게 하는 것일까?   
```
++(++pos);
```
바로 이러한 코드를 작성하기 위해서이다.       
그렇다면 왜 이러한 코드를 작성할 수 있게 한 것일까?         
기본 자료형 대상의 연산 동작을 그대로 구현했다는 것에 의미가 있다.       
(기본 자료형도 저렇게 표현이 가능하다 ```++(++val)```)       
   
### 2.1.2. 전위 증가와 후위 증가의 구분     
![cpp60](https://user-images.githubusercontent.com/50267433/74914263-7d2ea500-5405-11ea-9bfa-87c6074adfcd.PNG)     
         
후위 증가는 매개변수에 ```int```가 들어간다. (오버로딩 조건에 부합)       
참고로 후위 증가는 라인이 끝나면 증가하는 것인데 어떻게 구현을 할까?       
      
정의된 내용을 보면 ```operator++(int)```는 자신을 복사한 객체를 리턴해주고          
자신은 값이 하나 증가되는 것을 알 수 있다.       
          
즉 연산을 진행하는 라인에서는 복사본으로 처리를 하기에 값이 증가 되지 않은 것처럼 동작한다.      
   
### 2.1.3. 반환형에서의 const 선언과 const 객체  
const가 선언되면 그 값을 변경시킬 수 없는 상수의 형태가 된다.    
그렇기에 const 변수에 대한 참조자도 const로 선언이 되어 있어야한다.      
그리고 const 객체를 대상으로는 const 함수만 호출 가능하다.(```메소드()const{}```)  
        
![cpp61](https://user-images.githubusercontent.com/50267433/74915534-c253d680-5407-11ea-8471-7e18b899ed68.PNG)          
             
반환형이 const란 의미는 반환되는 객체를 const 객체화 하겠다는 의미이다.            
따라서 반환되는 객체를 대상으로 const로 선언되지 않은 함수의 호출이 불가능 하다.          
그렇기에 반환형에 const 선언을 붙여 주었고 ```const 객체형```으로 반환을 해주고 있다.          
(const 함수가 아닌 const 반환형이다 이 점 주의하자)         
        
이제 우리는 반환이 되었을 때 const 객체가 반환된다는 점을 기억해두자       
    
### 2.1.4. const 반환을 하는 이유    
![cpp62](https://user-images.githubusercontent.com/50267433/74917709-4c516e80-540b-11ea-9322-f9a2d0f871c0.PNG)    
후위 연산은 라인이 끝난 후에 동작이 되어야한다.     
그렇기에 const 선언을 한 이유는 위 그림과 같이 C++에서 허용하지 않는 연산의 컴파일을 하지 않기 위해서이다.  
     
***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
