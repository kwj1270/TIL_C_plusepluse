10 연산자 오버로딩1
=======================
스킬이 아닌 이해를 기준으로 학습을 하자     
# 1. 연산자 오버로딩의 이해와 유형         
예를 들어 Point 클래스를 참조하는 변수 p1 와 p2가 있다고 가정했을 시     
```
p1 + p2
```
위와 같이 ```객체 + 객체``` 구조는 원래는 성립되지 않는 구조이다.            
우선 ```C++```에서는 연산자에 매칭되는 함수를 실행시키고 그 함수에 피연산자를 인자로 넘긴다.   
```
예)
p1 + p2 -> p1.operator+(p2);
        -> operator+(p1, p2);
```   
함수는 ```멤버 함수```와 ```전역 함수```로 2가지 형태로 존재하는데          
멤버 함수라고 한다면 ```p1 operator+() p2``` 구조는 ```p1.operator+(p2)```이라고 볼 수 있다.    
**그리고 C++에서는 이러한 연산이 들어 왔을 때 처리하는 메소드를 오버라이딩 해줄 수 있다.**        
  
또한 전역함수로도 정의를 할 수 있다.   
이럴 경우  ```operator_plus(p1,p2)```구조로 실행이 된다.        
   
재미있는 점은 멤버함수나 전역함수로 정의하면 알맞은 구조로 알아서 실행해준다.     
   
이제 왜 '연산자 오버로딩'이란 이름을 사용했을까?       
이유는 간단하다 양 측에 있는 피 연산자들의 타입에 따라 실행 되는 메소드가 다르기 때문이다.  

## 1.1. operator+ 라는 이름의 함수
![cpp53](https://user-images.githubusercontent.com/50267433/74907793-68e3ab80-53f7-11ea-8bd4-fc571e2d0638.PNG)    
Point 클래스의 ```public:``` 에 위와 같이 메소드를 정의하게 되면     
![cpp54](https://user-images.githubusercontent.com/50267433/74907542-e824af80-53f6-11ea-8133-54912833fddc.PNG)      
외부에서 ```Pointer 변수 + 피연산자``` 연산을 진행을 할 수 있게 된다.        
         
단, 이러한 동작은 함수호출의 특정 규칙으로 인해 동작하는 것이므로 규칙을 이해하는 것이 중요하다   
    
## 1.2. 연산자를 오버로딩 하는 2가지 방법  
![cpp55](https://user-images.githubusercontent.com/50267433/74907970-e7404d80-53f7-11ea-949f-2716870dc248.PNG)      
이번에는 전역함수 방식으로 정의를 해놓은 것이다.      
friend 선언으로 Point 클래스의 private 멤버에 접근을 가능토록 만들어   
인자로 받아들인 값들의 멤버들에 접근하여 연산을 진행토록 하였다.   
   
![cpp56](https://user-images.githubusercontent.com/50267433/74907983-edcec500-53f7-11ea-8d5a-f0a45c79b18e.PNG)   
하는 일은 결과적으로 같다.   

### 1.2.1. 내용1
```
내용1
```

***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
