15 예외처리
=======================
# 1. 예외상황과 예외처리의 이해   
오류 : 코드상의 오류       
예외 : 코드상의 오류는 없으나 예기치 않은 입력으로 인하여 문제가 생기는 것      
     
## 1.1. 예외상황을 처리하지 않았을 때의 결과  
      
![cpp113](https://user-images.githubusercontent.com/50267433/76512743-94a6fe00-6498-11ea-900f-7555ea6b240b.PNG)          
     
**예외상황**은 프로그램 실행 중에 발생하는 문제의 상황을 의미한다.            
예외는 문법적 오류가 아닌, 프로그램 논리에 맞지 않는 오류를 뚯한다.            
            
## 1.2. if문을 이용한 예외의 처리   
      
![cpp114](https://user-images.githubusercontent.com/50267433/76512886-ca4be700-6498-11ea-8fbe-be395bc38089.PNG)   
      
if문을 이용하여 예외상황을 처리하기에는 많은 불편함이 있다.      
      
1. 예외처리 부분과 조건 부분을 구별하기가 힘들다   
2. 무수히 많은 가능성을 두고서는 무수히 많은 조건식을 넣어야 하므로 성능에 좋지 않다.     
     
그렇기에 C++에서는 예외처리를 위한 메커니즘을 제공하고 있다.  
***
# 2. C++의 예외처리 메커니즘   
## 2.1. C++의 예외처리 메커니즘 이해: try, catch, throw      
     
![cpp115](https://user-images.githubusercontent.com/50267433/76513499-bce32c80-6499-11ea-8730-0d0479dc6cd9.PNG)   

```
try   : 예외발생에 대한 검사범위를 지정하는데 사용된다.   
catch : try 블록에서 발생한 예외를 처리하는 영역으로 그 형태가 마차 반환형 없는 함수와 같다.   
throw : 예외 발생을 알리는 역할을 한다.   
```
```try ~ catch```는 하나의 문장이므로 그 사이에 다른 문장이 삽입될 수 없다.    

## 2.2. 예외처리 메커니즘의 적용    
   
![cpp116](https://user-images.githubusercontent.com/50267433/76514374-244dac00-649b-11ea-9cfe-4598628d9396.PNG)   
       
실행의 흐름을 잘 봐보도록 하자  
     
**에러 미존재**    
   
1. try 구문 실행
2. 일반 코드블록 수행 

**에러 존재**
   
1. try 구문 실행
2. if조건문으로 에러조건 판별후 throw 진행
3. catch로 넘어가서 catch 구문 실행  
4. try 다시 돌아가지 않고 일반 코드블록 수행     
      
예외의 발생으로 인해서 try 블록 내에서 throw절이 실행되면,      
try 블록의 나머지 부분은 실행이 되지 않는다!      

## 2.3. try 블록을 묶는 기준   
      
![cpp117](https://user-images.githubusercontent.com/50267433/76515084-56abd900-649c-11ea-9901-080397aec2e9.PNG)   
     
예외와 연관이 있는 부분을 모두 하나의 블록으로 묶어야 한다.      
예외처리를 진행후 try 구문으로 복귀하지 않고 일반 구문에서 다시 실행이 된다.      
하지만 이렇게 예외와 관련된 부분이 일반구문에 있을 경우 또다른 에러를 불러 일으킬 것이다.         
         
우리는 이렇게 예외와 연관이 있는 부분을 묶어주어야 한다고 했다.           
이는 하나의 트랜잭션 즉 기능단위로 묶는것과 동일하며         
try를 통해 하나의 기능의 범위를 구별할 수 있는 척도가 될 수 있다.       
          
***
# 3. Stack Unwinding(스택 풀기)         
## 3.1. 예외의 전달   
       
![cpp118](https://user-images.githubusercontent.com/50267433/76516131-4268db80-649e-11ea-92f7-6933a569a5d5.PNG)      
       
```thorw``` 처리를 진행해도 예외처리를 진행하지 않는다면 (try블록이 없다)             
예외 데이터를 해당 메소드를 호출한 곳으로 전달한다.(책임전가한다.)         
그리고 마지막에는 main이 될텐데 이마저도 처리를 안하면 os에서 예외를 받게 되어 프로그램을 종료시킨다.   
          
## 3.2. 예외의 발생위치와 처리위치가 달라야 하는 경우   
      
![cpp119](https://user-images.githubusercontent.com/50267433/76517239-4dbd0680-64a0-11ea-8dcb-70f6c0f23167.PNG)  
     
위 코드는 단순해 보일지라도 많은 의미가 담겨 있다.   
우선 메소드의 의미를 따지자면 하나의 기능을 나타내는 것이다.    
    
메소드내에서 에러가 발생했다는 것은 해당 기능을 사용할 수 없음을 나타내고 있다.   
이는 에러가 발생시 try 구문으로 돌아가지 않고 catch 다음의 일반 구문이 실행된다는 특징을 이용한다.  
즉, 프로그램의 실행이 에러가 발생하면 다시 메소드로 돌아가지 않는다는 것이다.    
       
## 3.3. 스택 풀기 (stack Unwinding)         
        
![cpp120](https://user-images.githubusercontent.com/50267433/76518307-3717af00-64a2-11ea-962e-bdcd43265821.PNG)   
         
예외처리를 진행하지 않으면 자신을 호출한 곳으로  예외데이터를 전달된다.                 
C++ 프로그램의 동작 프로세스는 스택을 기반으로 하고 있기 때문에                
스택순으로 역으로 다시 예외데이터가 전달되는 것이다.             
마지막으로는 main 함수에 os를 예외데이터를 전달하고 os에서는 처리를 할 수 없으니 terminate를 실행한다.        
            
## 3.4. 자료형이 일치하지 않아도 예외 데이터는 전달       
    
![cpp121](https://user-images.githubusercontent.com/50267433/76519100-b194fe80-64a3-11ea-8e71-26e921588e5c.PNG)    
         
자료형이 일치하지 않아도 예외 데이터는 전달이 된다.             
이 말은 전달은 되지만 무조건 적으로 catch로 처리가 된다는 것은 아니다.        
          
```catch``` 구문은 예외데이터 자료형이 일치할 경우 실행된다.       
즉, 전달된다는 것은 호출된곳으로 넘어간다는 뜻이다.        
예외 처리를 진행하고 싶으면 자료형을 일치시켜야 한다.      
     
## 3.5. 하나의 try 블록과 다수의 catch 블록      
     
![cpp122](https://user-images.githubusercontent.com/50267433/76519958-45b39580-64a5-11ea-87ea-24abacbe7fc1.PNG)   
하나의 try 영역 내에서 종류가 다른 둘 이상의 예외가 발생할 수 있기 때문에,   
하나의 try 블록에 다수의 catch 블록을 추가할 수 있다.   
     
## 3.6. 전달되는 예외의 명시     
         
![cpp123](https://user-images.githubusercontent.com/50267433/76521495-4a2d7d80-64a8-11ea-84f8-d67bf1d4cb96.PNG)      

```
int simpleFunc(void) throw(int, char)
{
     .    .    .    .    .
}
```

함수에 전달되는 예외를 명시해줄 수 있다.      
즉, 함수 내에서 발생하는 예외가 무엇이다를 지정해주는 것이다.       
이렇게 정의 할 경우 해당 예외가 발생하면 이를 호출한 곳을 예외 데이터를 전달하지만     
정의되지 않은 예외가 발생하면 프로그램을 종료시킨다.       
      
프로그램을 종료시키기에 좋지 않다고 볼 수 있지만 이는 완전 반대이다.      
      
예상 가능한 예외를 처리를 진행하고 예상치 못한 예외 발생시 프로그램을 종료시켜     
정의된 예외처리에 대해서 안정성을 띄우며 예상치 못한 예외를 발견할 수도 있고      
예외에 대해 명확히 표현할 수 있다.    
   
```
int simpleFunc(void) throw()
{
     .    .    .    .    .
}
```
이렇게 아무 자료형도 정의 해주지 않을 수 있는데       
이는 소스코드에 에러 상황이 없다고 말을 해주는 것이다.     
즉, 에러가 있으면 ```terminate``` 발생해 프로그램을 종료시킬 것이다.      
    
## 3.7. 예외 클래스와 예외 객체   






