C++ 정리-01
=======================
이미 알고 있는 내용이나 너무 기초적인 내용은 정리하지 않겠습니다.

1. std::cout<<"Hello world"<<endl;
2. std::cin>>val;
3. for(int i 가능)
4. char name[100] 배열 선언
5. 오버로딩(이름+ 매개변수형태, 단 반환형x, 추가로 const도 조건이 됨)
6. void function(default int i = 20) 디폴트 매개변수 (뒤에서부터 정의해야 함)
7. 인라인함수-매크로함수이며, 클래스내의 함수들은 인라인 함수로 취급 (코드량 적을때 사용 좋음)
8. NameSpace : 다양한 라이브러리에 존재하는 동일한 식별자들의 충돌을 막기 위해 사용
9. using : 자주 사용하는 네임스페이스에 대한 기술을 단축하기 위해서 사용
10. 범위지정 연산자(default namespace) 메소드내에서 val와 ::val는 다르다
11. const는 상수 지정 생성과 동시에 초기화를 진행해주어야 한다.  
12. 참조자 : call-by-reference를 기준으로 할당된 메모리 공간에 이름을 추가로 붙이는 것이다.   
  * 참조자의 수에는 제한이 없다.  
  * 변수에 대해서만 선언이 가능하고 동시에 누군가를 참조해야 한다. (생성과 동시에 초기화)
  * 리턴형으로 사용되었을 경우 일반 변수 or 참조 변수로 받을 수 있음 (차이는 메모리 생성유무)
13. new & delete (기본적으로 포인터 변수로 할당 받지만 참조자를 이용하면 더욱 간단해진다)   
14. 객체에서의 new & delete 는 일반 변수 선언하듯이 하면 된다.  
15. 클래스 개념 및 생성 방법 및 접근제어 지시자 
16. 클래스 파일 분할 (h 파일: 클래스 구조, c 파일: 메소드 내용)   
17. 정보은닉 : 멤버변수 private, 멤버함수 public , 캡슐화 : 연관된 모음이자 집합 
18. const 객체와 const 함수 : const 선언된 객체는 const 함수만 호출 가능  
19. 생성자 : 객체 생성시에 실행되는 메소드
  * 디폴트 생성자 : 생성자를 정의 하지 않았을 때 호출됨 -> void 형이며   
    * ```Class class;```
    * ```Class class = new Class```
    * ```Class class = new Class()```
  * 사용자 정의 생성자 : 인자로 넘어오는 값에 따른 생성자 정의,       
  단 정의 했을시 디폴트 생성자는 호출되지 않으므로 void 생성자를 따로 정의 해주는 것이 좋다.     
  그리고 인자로 넘기는 값이 있다면    
  * ```Class class(100);```   
  * ```Class class = new Class(100)```
  ```()```를 이용하여 바로 생성가능하고 이는 생성자를 호출한 것이다.
20. 이니셜라이저 : 생성자에서 멤버 할당을 생성과 동시에 하도록 해줌     
  * 멤버로 클래스일 경우 해당 클래스에 맞는 생성자 호출
  * 멤버로 일반 변수일 경우 묵시적 형태로 호출
21. 소멸자의 이해 : 생성자에 ```~```를 붙인 형태로 클래스내 할당된 메모리를 삭제할 것을 정의
22. this 포인터 : 객체 자기 자신을 의미하는 포인터 변수  
23. 복사 생성자 ```객체1 = 객체2```를 ```객체1(객체2)```형태의 생성자로 생성하는 것이다.   
  * 디폴트 복사 생성자 : 복사 생성자를 정의하지 않았으면 자동으로 호출된다.      
  디폴트 복사 생성자에는 문제점이 있는데 바로 얕은 복사를 진행하는 것이다.     
  만일 멤버에 메모리를 가리키는 변수가 있다면 그것이 복사되어 같은 메모리를 가리키는 형태가 된다.    
  이는 소멸자로 소멸할 시에 가리키는 대상이 같이 소멸되는 문제점을 야기한다.        
  * 사용자 정의 복사 생성자 : new 키워드를 이용해서 새로운 메모리에 할당하는 식으로 정의해주자     
  * **그 외** 복사생성자와 대입 연산자 오버로딩이 헷갈리니 주의하자     
  초기화를 진행하면 생성자 초기화 이외에 할다이면 대입 연산자 오버로딩     
24. explicit : 묵시적 형 변환으로의 변환으 막음 ```Class calss(3)```이런식으로만 가능  
25. const 객체 : const로 선언되지 않는 멤버함수의 호출이 불가능하다
26. friend 키워드 : firend로 선언된 클래스는 현재 클래스의 private도 접근 가능 (함수에 정의 가능)   
27. static 키워드 : 
  * 전역변수에 선언된 static : 선언된 파일 내에서만 참조를 허용 
  * 함수내 변수에 선언된 static : 한번만 초기화되고, 지역변수와 달리 빠져나와도 소멸되지 않는다.      
  * static 멤버 변수 : 멤버변수가 아니니 생성자에서 초기화 하는 것이 아닌 밖에서 초기화 권고           
  public 접근제어자를 가졌으면 외부에서 ```Class::static변수명```으로 사용 가능하다.         
  * static 멤버 함수 : 객체의 멤버로 존재하는 것은 마찬가지로 아니다. (네임스페이스 이용이라 보면된다)     
  선언된 클래스의 모든 객체가 공유하며 public으로 선언이 되면, ```Class::static함수명```으로 사용 가능하다.    
  참고로 static 멤버 함수는 객체가 생성되기 전에 존재하는 것이므로 클래스내에서는 staic변수만 접근 가능하다.     
28. const static 키워드 : 클래스가 정의될 때 공통으로 사용하는 상수를 지정할 때 주로 사용한다.   
29. mutable 키워드 : mutable로 선언된 멤버 변수는 const 함수내에서 접근이 가능하다.   
